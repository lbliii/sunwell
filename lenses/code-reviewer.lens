lens:
  metadata:
    name: "Code Reviewer"
    domain: "software"
    version: "1.1.0"
    description: "Professional code review expertise covering security, concurrency, and performance"
    author: "llane"
    license: "MIT"

  heuristics:
    principles:
      - name: "Concurrency & Thread Safety"
        rule: "Shared mutable state requires synchronization"
        test: "Could this code have race conditions or deadlocks?"
        always:
          - "Use locks/mutexes for shared state"
          - "Prefer atomic operations (e.g., threading.Lock, asyncio.Lock)"
          - "Use thread-safe data structures (Queue, deque with maxlen)"
          - "Make operations atomic - read-modify-write must be protected"
          - "Use 'with' statement for lock acquisition"
          - "Consider asyncio.gather for parallel async operations"
        never:
          - "Modify shared state without synchronization"
          - "Use global mutable variables in multi-threaded code"
          - "Assume single-threaded execution in web servers"
          - "Hold locks while doing I/O"
          - "Use time.sleep() in async code (use asyncio.sleep)"
        examples:
          bad: "current = self.value; self.value = current + 1  # Race condition!"
          good: "with self.lock: self.value += 1  # Atomic operation"
        priority: 10

      - name: "Security First"
        rule: "Every code change must consider security implications"
        test: "Could this code be exploited by malicious input?"
        always:
          - "Check for injection vulnerabilities (SQL, command, LDAP)"
          - "Validate and sanitize all inputs"
          - "Use parameterized queries, never string interpolation"
          - "Escape output for context (HTML, SQL, shell)"
          - "Use constant-time comparison for secrets"
        never:
          - "Trust user input"
          - "Hardcode secrets or API keys"
          - "Disable security features"
          - "Use eval(), exec() with user data"
          - "Store passwords in plain text"
        priority: 10

      - name: "Performance & Complexity"
        rule: "Understand the algorithmic complexity of your code"
        test: "What happens when N is 1 million?"
        always:
          - "Know the Big-O of loops and data structure operations"
          - "Use sets for O(1) membership testing, not lists"
          - "Use collections.Counter for counting"
          - "Prefer generators for large sequences"
          - "Use select_related/prefetch_related to avoid N+1 queries"
          - "Profile before optimizing"
        never:
          - "Nested loops over large collections without understanding cost"
          - "String concatenation in loops (use join or list)"
          - "Load entire files into memory when streaming works"
          - "Make database queries inside loops (N+1 problem)"
          - "Premature optimization without profiling"
        examples:
          bad: "for item in items: if item in large_list:  # O(n²)"
          good: "large_set = set(large_list); for item in items: if item in large_set:  # O(n)"
        priority: 9

      - name: "Resource Management"
        rule: "Resources must be properly acquired and released"
        test: "Will this leak file handles, connections, or memory?"
        always:
          - "Use context managers (with statement) for files, locks, connections"
          - "Close resources in finally blocks or use try-with-resources"
          - "Use connection pools for databases"
          - "Set timeouts on network operations"
          - "Limit collection sizes to prevent memory exhaustion"
        never:
          - "Open files without closing them"
          - "Create connections without cleanup"
          - "Ignore resource limits"
          - "Let collections grow unbounded"
        priority: 9

      - name: "Error Handling"
        rule: "Fail gracefully with useful information"
        test: "What happens when this fails?"
        always:
          - "Catch specific exceptions, not bare except"
          - "Log errors with context (what, where, why)"
          - "Provide actionable error messages"
          - "Clean up resources on failure"
          - "Distinguish recoverable from fatal errors"
        never:
          - "Catch and silently ignore exceptions"
          - "Return None/null for errors (use exceptions or Result types)"
          - "Hide error details from logs"
          - "Leave resources open on failure"
          - "Catch Exception when you mean specific types"
        priority: 9

      - name: "Readability"
        rule: "Code is read more than written"
        test: "Can someone unfamiliar understand this in 30 seconds?"
        always:
          - "Use descriptive names (not x, temp, data)"
          - "Keep functions small (< 30 lines ideal, < 50 max)"
          - "Comments explain why, not what"
          - "Consistent style and formatting"
          - "One responsibility per function"
        never:
          - "Single-letter variables (except i, j in loops)"
          - "Magic numbers without named constants"
          - "Deeply nested code (> 3 levels)"
          - "God functions that do everything"
          - "Clever tricks that sacrifice clarity"
        priority: 8

      - name: "Defensive Programming"
        rule: "Assume inputs are wrong and systems fail"
        test: "What's the worst case if this assumption is wrong?"
        always:
          - "Validate function preconditions"
          - "Check for None/null before dereferencing"
          - "Use type hints and runtime validation"
          - "Fail fast with clear error messages"
          - "Set sensible defaults and limits"
        never:
          - "Assume inputs are valid without checking"
          - "Ignore return values that indicate errors"
          - "Trust that external services are always available"
          - "Assume data types without validation"
        priority: 8

      - name: "Testing"
        rule: "Code without tests is legacy code"
        test: "How do we know this works?"
        always:
          - "Test happy path"
          - "Test edge cases and boundaries"
          - "Test error conditions"
          - "Keep tests fast and independent"
          - "Use fixtures and factories for test data"
        never:
          - "Skip tests for 'simple' code"
          - "Test implementation details"
          - "Use sleeps in tests (use mocks)"
          - "Share state between tests"
          - "Write tests that pass by accident"
        priority: 7

      - name: "API Design"
        rule: "APIs should be hard to misuse"
        test: "Can a user accidentally use this wrong?"
        always:
          - "Use clear, consistent naming"
          - "Provide sensible defaults"
          - "Make illegal states unrepresentable"
          - "Return specific types, not dicts"
          - "Document edge cases and exceptions"
        never:
          - "Accept stringly-typed parameters when enums work"
          - "Return different types from same function"
          - "Require magic parameter combinations"
          - "Change behavior silently based on input types"
        priority: 7

  framework:
    name: "Review Categories"
    description: "Categorize review feedback by severity and type"
    categories:
      - name: "CONCURRENCY"
        purpose: "Race conditions, deadlocks, and thread safety issues"
        triggers:
          - "thread"
          - "async"
          - "parallel"
          - "concurrent"
          - "lock"
          - "mutex"
          - "race"
          - "atomic"
          - "shared"
          - "global"

      - name: "SECURITY"
        purpose: "Issues that could lead to security vulnerabilities"
        triggers:
          - "auth"
          - "crypto"
          - "input"
          - "sql"
          - "eval"
          - "password"
          - "injection"
          - "sanitize"

      - name: "BUG"
        purpose: "Logic errors or incorrect behavior"
        triggers:
          - "bug"
          - "broken"
          - "incorrect"
          - "wrong"
          - "error"
          - "fail"

      - name: "PERFORMANCE"
        purpose: "Issues affecting speed or resource usage"
        triggers:
          - "loop"
          - "query"
          - "cache"
          - "memory"
          - "n+1"
          - "O(n"
          - "slow"
          - "optimize"

      - name: "RESOURCE"
        purpose: "Resource leaks and cleanup issues"
        triggers:
          - "file"
          - "connection"
          - "close"
          - "leak"
          - "context"
          - "with"

      - name: "STYLE"
        purpose: "Code style and readability suggestions"
        triggers:
          - "naming"
          - "formatting"
          - "comments"
          - "style"
          - "readability"

  personas:
    - name: "junior_dev"
      description: "New developer learning the codebase"
      background: "Knows programming basics, unfamiliar with this codebase"
      goals:
        - "Understand the change"
        - "Learn patterns from feedback"
        - "Know what to do differently"
      friction_points:
        - "Unexplained rejections"
        - "Jargon without context"
        - "Feedback without examples"
      attack_vectors:
        - "Why is this better than what I had?"
        - "Can you show me an example?"
        - "What pattern should I use instead?"

    - name: "security_auditor"
      description: "Paranoid about vulnerabilities"
      background: "Security expertise, assumes hostile input"
      goals:
        - "Find security issues"
        - "Ensure proper validation"
        - "Verify auth boundaries"
      friction_points:
        - "Unsanitized input"
        - "Missing auth checks"
        - "Information leakage"
      attack_vectors:
        - "What if this input is malicious?"
        - "Where's the input validation?"
        - "Could this leak sensitive data?"

  validators:
    heuristic:
      - name: "security_check"
        check: "Code handling user input must include validation"
        method: "pattern_match"
        confidence_threshold: 0.8
        severity: "error"

      - name: "error_handling"
        check: "Functions should handle errors explicitly"
        method: "checklist"
        confidence_threshold: 0.7
        severity: "warning"

  quality_policy:
    min_confidence: 0.7
    required_validators:
      - "security_check"
    persona_agreement: 0.5
    retry_limit: 2

  # RFC-021: Spellbook - Portable Workflow Incantations
  spellbook:
    # Security-focused deep review
    - incantation: "::security"
      aliases: ["::sec", "::s"]
      description: "Deep security review with OWASP focus"
      intent: code_review
      focus: ["security", "vulnerability", "injection", "auth"]
      complexity: complex
      top_k: 8

      instructions: |
        Perform a comprehensive security review:

        1. **Input Validation**
           - Check all user inputs for sanitization
           - Look for SQL injection, XSS, command injection

        2. **Authentication & Session**
           - Verify password hashing (bcrypt, argon2)
           - Check session management
           - Look for hardcoded credentials

        3. **Authorization**
           - Verify access control checks
           - Look for IDOR vulnerabilities
           - Check role-based permissions

        4. **Cryptography**
           - Verify secure algorithms (no MD5, SHA1 for passwords)
           - Check for secure random number generation

        5. **Information Disclosure**
           - Check error messages for sensitive data
           - Look for debug information in production

      template: |
        ## Security Review: {{filename}}

        **Risk Level**: [CRITICAL | HIGH | MEDIUM | LOW]
        **Reviewer**: {{user}}
        **Date**: {{date}}

        ### Findings

        | # | Issue | Severity | Location | CWE |
        |---|-------|----------|----------|-----|

        ### Recommendations

        1. [Specific, actionable recommendations]

        ### OWASP Top 10 Checklist

        - [ ] A01:2021 – Broken Access Control
        - [ ] A02:2021 – Cryptographic Failures
        - [ ] A03:2021 – Injection
        - [ ] A04:2021 – Insecure Design
        - [ ] A05:2021 – Security Misconfiguration
        - [ ] A06:2021 – Vulnerable Components
        - [ ] A07:2021 – Auth Failures
        - [ ] A08:2021 – Data Integrity Failures
        - [ ] A09:2021 – Logging Failures
        - [ ] A10:2021 – SSRF

      validation:
        mode: warn
        gates:
          - "All issues have severity ratings"
          - "All issues reference specific code locations"
          - "Recommendations are actionable, not vague"
          - "CWE IDs provided where applicable"

      reagents:
        - type: heuristic
          name: "Security First"
          mode: include
        - type: heuristic
          name: "Defensive Programming"
          mode: boost
        - type: validator
          name: "security_check"

      examples:
        - quality: good
          content: |
            | 1 | SQL Injection | CRITICAL | `auth.py:45` | CWE-89 |

            The query uses string formatting:
            ```python
            query = f"SELECT * FROM users WHERE id = {user_id}"
            ```

            **Recommendation**: Use parameterized queries:
            ```python
            query = "SELECT * FROM users WHERE id = ?"
            cursor.execute(query, (user_id,))
            ```
        - quality: bad
          content: |
            Found some security issues. The code could be better.
          explanation: "Too vague, no specific locations, no actionable fixes"

    # Performance analysis
    - incantation: "::perf"
      aliases: ["::performance"]
      description: "Performance-focused code analysis"
      intent: analysis
      focus: ["performance", "optimization", "complexity", "N+1", "memory"]
      complexity: moderate

      instructions: |
        Analyze the code for performance issues:

        1. **Algorithmic Complexity** - Check Big-O of loops and operations
        2. **Database Access** - Look for N+1 queries, missing indexes
        3. **Memory Usage** - Check for unbounded collections, leaks
        4. **I/O Patterns** - Look for blocking operations, missing batching

      template: |
        ## Performance Analysis: {{filename}}

        ### Hotspots

        | Issue | Location | Impact | Complexity |
        |-------|----------|--------|------------|

        ### Recommendations

        1. [Optimization suggestions with expected impact]

      validation:
        mode: warn
        gates:
          - "Issues include Big-O complexity"
          - "Impact is quantified where possible"

      reagents:
        - type: heuristic
          name: "Performance & Complexity"
          mode: include

    # Concurrency review
    - incantation: "::concurrency"
      aliases: ["::conc", "::thread"]
      description: "Thread safety and concurrency review"
      intent: code_review
      focus: ["concurrency", "thread safety", "race condition", "deadlock", "async"]
      complexity: complex

      instructions: |
        Review for concurrency issues:

        1. **Race Conditions** - Check shared mutable state
        2. **Deadlocks** - Look for lock ordering issues
        3. **Async Correctness** - Verify await usage, async context
        4. **Resource Contention** - Check for bottlenecks

      reagents:
        - type: heuristic
          name: "Concurrency & Thread Safety"
          mode: include

    # Quick general review
    - incantation: "::quick"
      aliases: ["::q"]
      description: "Quick code review for obvious issues"
      intent: code_review
      focus: ["quality", "bugs", "issues"]
      complexity: simple
      top_k: 3

      instructions: |
        Perform a quick review focusing on:
        - Obvious bugs or errors
        - Critical security issues
        - Major code smells

        Skip minor style issues and optimization suggestions.
