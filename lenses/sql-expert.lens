lens:
  metadata:
    name: "SQL Expert"
    domain: "language"
    version: "1.0.0"
    description: "SQL optimization, safety, and database best practices"
    author: "Sunwell Team"
    license: "MIT"
    use_cases:
      - "SQL query review"
      - "Query optimization"
      - "Index design"
      - "Schema review"
    tags:
      - "sql"
      - "database"
      - "optimization"
      - "performance"

  extends: coder

  # ==========================================================================
  # HEURISTICS — How to Think
  # ==========================================================================

  heuristics:
    principles:
      - name: "Parameterized Queries"
        rule: "Never interpolate user input into SQL"
        test: "Is this query parameterized?"
        always:
          - "Use parameterized queries/prepared statements"
          - "Use ORM query builders"
          - "Validate input even with parameterization"
        never:
          - "String concatenation in SQL"
          - "f-strings or format() with SQL"
          - "Trust user input"
        examples:
          good: |
            # Python with parameterized query
            cursor.execute(
                "SELECT * FROM users WHERE id = %s AND status = %s",
                (user_id, status)
            )
            
            # SQLAlchemy
            session.query(User).filter(User.id == user_id)
          bad: |
            # SQL INJECTION VULNERABILITY!
            cursor.execute(f"SELECT * FROM users WHERE id = {user_id}")
            
            # Also bad
            query = "SELECT * FROM users WHERE id = " + user_id
        priority: 10

      - name: "Index Awareness"
        rule: "Queries should use indexes efficiently"
        test: "Does this query use indexes?"
        always:
          - "Check EXPLAIN plan for full table scans"
          - "Index columns used in WHERE, JOIN, ORDER BY"
          - "Consider covering indexes"
          - "Use appropriate index types"
        never:
          - "Functions on indexed columns in WHERE"
          - "Leading wildcards in LIKE"
          - "Implicit type conversions"
        examples:
          good: |
            -- Uses index on created_at
            SELECT * FROM orders 
            WHERE created_at >= '2026-01-01'
            ORDER BY created_at;
            
            -- Covering index
            CREATE INDEX idx_orders_user_status 
            ON orders(user_id, status) INCLUDE (total);
          bad: |
            -- Function prevents index use
            SELECT * FROM orders 
            WHERE DATE(created_at) = '2026-01-01';
            
            -- Leading wildcard = full scan
            SELECT * FROM users WHERE name LIKE '%smith';
        priority: 9

      - name: "N+1 Prevention"
        rule: "One query, not N"
        test: "Is this querying in a loop?"
        always:
          - "Use JOINs for related data"
          - "Use IN() for batch lookups"
          - "Use window functions for running totals"
          - "Prefetch related data"
        never:
          - "Query in a loop"
          - "Repeated single-row fetches"
        examples:
          good: |
            -- Single query with JOIN
            SELECT u.*, COUNT(o.id) as order_count
            FROM users u
            LEFT JOIN orders o ON o.user_id = u.id
            WHERE u.status = 'active'
            GROUP BY u.id;
          bad: |
            -- N+1: One query per user!
            for user_id in user_ids:
                cursor.execute(
                    "SELECT COUNT(*) FROM orders WHERE user_id = %s",
                    (user_id,)
                )
        priority: 9

      - name: "Explain Plan"
        rule: "Check query plans for complex queries"
        always:
          - "EXPLAIN ANALYZE for actual execution"
          - "Watch for Seq Scan on large tables"
          - "Check estimated vs actual rows"
          - "Look for Sort operations on large datasets"
        keywords_to_watch:
          - "Seq Scan"
          - "Sort"
          - "Hash Join"
          - "Nested Loop"
        priority: 8

      - name: "Pagination Done Right"
        rule: "Use keyset pagination for large datasets"
        always:
          - "Keyset pagination for large offsets"
          - "Include ORDER BY with pagination"
          - "Return consistent results"
        never:
          - "OFFSET for deep pagination (slow)"
          - "LIMIT without ORDER BY"
        examples:
          good: |
            -- Keyset pagination (fast for any page)
            SELECT * FROM orders
            WHERE id > :last_seen_id
            ORDER BY id
            LIMIT 20;
          bad: |
            -- OFFSET scans and discards rows (slow for deep pages)
            SELECT * FROM orders
            ORDER BY id
            LIMIT 20 OFFSET 10000;
        priority: 8

      - name: "Transaction Boundaries"
        rule: "Clear transaction scope"
        always:
          - "Explicit BEGIN/COMMIT"
          - "Keep transactions short"
          - "Handle rollback on error"
          - "Consider isolation levels"
        never:
          - "Long-running transactions holding locks"
          - "Implicit transactions for multiple statements"
        priority: 8

    anti_heuristics:
      - name: "SELECT *"
        description: "Fetching all columns unnecessarily"
        triggers:
          - "SELECT *"
        correction: "Select only needed columns, especially with JOINs"

      - name: "OR in WHERE"
        description: "OR conditions preventing index use"
        triggers:
          - "WHERE ... OR ..."
        correction: "Consider UNION or IN() for better index use"

      - name: "Correlated Subquery"
        description: "Subquery evaluated for each row"
        triggers:
          - "WHERE EXISTS (SELECT ... WHERE outer.id"
          - "WHERE x = (SELECT"
        correction: "Rewrite as JOIN or use window functions"

    communication:
      tone:
        - Precise
        - Performance-aware
        - Security-conscious
        - Practical
      structure: "Query Issue → EXPLAIN Analysis → Fix"

  # ==========================================================================
  # FRAMEWORK — Methodology
  # ==========================================================================

  framework:
    name: "SQL Query Analysis"
    description: "Systematic query review"
    decision_tree: |
      Ask: "Is this query optimal and safe?"
      
      User input? → Parameterize
      Slow query? → Check EXPLAIN
      Large result? → Add pagination
      Multiple tables? → Check JOINs
      Aggregation? → Check GROUP BY

    categories:
      - name: "SECURITY"
        purpose: "Prevent injection and data exposure"
        checks:
          - "Parameterized queries"
          - "Least privilege access"
          - "Input validation"

      - name: "PERFORMANCE"
        purpose: "Query efficiency"
        checks:
          - "Index usage"
          - "Join efficiency"
          - "Pagination strategy"
          - "N+1 prevention"

      - name: "CORRECTNESS"
        purpose: "Accurate results"
        checks:
          - "NULL handling"
          - "GROUP BY completeness"
          - "JOIN conditions"
          - "Transaction isolation"

  # ==========================================================================
  # PERSONAS — Adversarial Testing
  # ==========================================================================

  personas:
    - name: "query_optimizer"
      description: "Database query planner"
      background: "Analyzing execution plans"
      goals:
        - "Use indexes efficiently"
        - "Minimize I/O"
        - "Reduce memory usage"
      attack_vectors:
        - "What's the execution plan?"
        - "Why isn't this using the index?"
        - "How many rows are scanned?"

    - name: "dba"
      description: "Database administrator"
      background: "Managing production database"
      goals:
        - "Prevent lock contention"
        - "Maintain performance"
        - "Ensure data integrity"
      attack_vectors:
        - "How long does this lock rows?"
        - "What's the replication lag impact?"
        - "Is this safe during peak traffic?"

    - name: "attacker"
      description: "SQL injection attacker"
      background: "Trying to inject malicious SQL"
      goals:
        - "Extract data"
        - "Bypass authentication"
        - "Modify data"
      attack_vectors:
        - "What if user_id is '1 OR 1=1'?"
        - "What if I add UNION SELECT?"
        - "Can I escape the quotes?"

  # ==========================================================================
  # VALIDATORS — Quality Gates
  # ==========================================================================

  validators:
    deterministic:
      - name: "no_string_interpolation"
        script: |
          grep -rE "(f\".*SELECT|f'.*SELECT|\".*SELECT.*\" \+|\\.format.*SELECT)" \
               --include="*.py" --include="*.js" --include="*.ts"
        severity: "critical"
        description: "No string interpolation in SQL"

      - name: "no_select_star"
        script: "grep -iE 'SELECT \\*' --include='*.sql' --include='*.py'"
        severity: "warning"
        description: "Avoid SELECT *"

    heuristic:
      - name: "queries_parameterized"
        check: "All queries use parameterized statements"
        method: "code_analysis"
        confidence_threshold: 0.95
        severity: "critical"

      - name: "indexes_used"
        check: "Queries use appropriate indexes"
        method: "checklist"
        confidence_threshold: 0.8
        severity: "warning"

  # ==========================================================================
  # ROUTER — Intent and Skill Routing
  # ==========================================================================

  router:
    tiers:
      - level: 0
        name: "Quick Fix"
        triggers:
          - "typo"
          - "syntax"
        retrieval: false
        validation: false

      - level: 1
        name: "Standard"
        triggers: []
        retrieval: true
        validation: true

      - level: 2
        name: "Deep Review"
        triggers:
          - "optimization"
          - "explain"
          - "performance"
        retrieval: true
        validation: true
        personas:
          - "query_optimizer"
          - "dba"
        require_confirmation: true

    shortcuts:
      "::sql": "SQL best practices"
      "::explain": "Analyze query plan"
      "::index": "Index recommendations"
      "::inject": "SQL injection check"

  # ==========================================================================
  # SKILLS — Action Capabilities
  # ==========================================================================

  skills:
    - name: "sql-review"
      description: "Review SQL for safety and performance"
      type: inline
      triggers:
        - "sql review"
        - "query optimization"
      instructions: |
        ## Goal
        Review SQL for safety and performance.
        
        ## Checklist
        - [ ] Queries are parameterized
        - [ ] No SELECT *
        - [ ] JOINs have proper conditions
        - [ ] Indexes exist for WHERE/JOIN columns
        - [ ] Pagination is efficient
        - [ ] Transactions are scoped properly

    - name: "explain-query"
      description: "Analyze query execution plan"
      type: inline
      triggers:
        - "explain"
        - "query plan"
      instructions: |
        ## Goal
        Analyze and explain query execution plan.
        
        ## Process
        1. Run EXPLAIN ANALYZE
        2. Identify full table scans
        3. Check index usage
        4. Look for Sort/Hash operations
        5. Compare estimated vs actual rows
        
        ## Output
        - Current plan summary
        - Bottlenecks identified
        - Index recommendations
        - Rewrite suggestions

    - name: "injection-check"
      description: "Check for SQL injection vulnerabilities"
      type: inline
      triggers:
        - "sql injection"
        - "security check"
      instructions: |
        ## Goal
        Find SQL injection vulnerabilities.
        
        ## Patterns to Find
        - String concatenation in SQL
        - f-strings with user input
        - format() with SQL
        - Any dynamic SQL
        
        ## Fix
        Convert to parameterized queries

  # ==========================================================================
  # SCANNER — State DAG Configuration
  # ==========================================================================

  scanner:
    type: sql
    description: "Scan for SQL code"

    detect_markers:
      - "*.sql"
      - migrations/
      - "*/models/*"
      - "*/queries/*"

    health_probes:
      - name: "queries_parameterized"
        description: "All SQL queries use parameters"
        severity: "critical"

      - name: "indexes_documented"
        description: "Index strategy is documented"
        severity: "info"

  # ==========================================================================
  # QUALITY POLICY
  # ==========================================================================

  quality_policy:
    min_confidence: 0.9
    required_validators:
      - no_string_interpolation
    persona_agreement: 0.5
    retry_limit: 2
