lens:
  metadata:
    name: "Rust Expert"
    domain: "language"
    version: "1.0.0"
    description: "Rust ownership, safety, performance, and idiomatic patterns"
    author: "Sunwell Team"
    license: "MIT"
    use_cases:
      - "Rust code review"
      - "Ownership guidance"
      - "Error handling"
      - "Performance optimization"
    tags:
      - "rust"
      - "ownership"
      - "safety"
      - "performance"

  extends: coder

  # ==========================================================================
  # HEURISTICS — How to Think
  # ==========================================================================

  heuristics:
    principles:
      - name: "Ownership First"
        rule: "Understand ownership before fighting the borrow checker"
        test: "Is ownership clear for all values?"
        always:
          - "Move semantics by default"
          - "Clone only when necessary"
          - "Borrow instead of own when possible"
          - "Use references for read-only access"
        never:
          - "Clone to silence borrow checker"
          - "Excessive Rc/Arc without justification"
          - "Ignore lifetime annotations"
        examples:
          good: |
            fn process(data: &str) -> String {
                // Borrows data, returns owned String
                data.to_uppercase()
            }
            
            fn consume(data: String) {
                // Takes ownership, can't use data after call
                println!("{}", data);
            }
          bad: |
            fn process(data: String) -> String {
                // Unnecessary ownership transfer
                // Caller must clone if they need data later
                data.to_uppercase()
            }
        priority: 10

      - name: "Result Everywhere"
        rule: "Result<T, E> over panic"
        test: "Are errors propagated with Result?"
        always:
          - "? operator for propagation"
          - "thiserror for custom library errors"
          - "anyhow for application errors"
          - "impl std::error::Error for custom errors"
        never:
          - "unwrap() in library code"
          - "expect() without specific reason"
          - "panic!() for recoverable errors"
        examples:
          good: |
            use thiserror::Error;
            
            #[derive(Error, Debug)]
            pub enum ParseError {
                #[error("invalid format: {0}")]
                InvalidFormat(String),
                #[error("io error")]
                Io(#[from] std::io::Error),
            }
            
            fn parse(input: &str) -> Result<Data, ParseError> {
                let file = std::fs::read_to_string(input)?;  // ? converts error
                // ...
            }
          bad: |
            fn parse(input: &str) -> Data {
                let file = std::fs::read_to_string(input).unwrap();  // Panics!
                // ...
            }
        priority: 10

      - name: "Zero-Cost Abstractions"
        rule: "Abstractions compile away"
        test: "Does this abstraction have runtime cost?"
        always:
          - "Iterators over explicit loops"
          - "Traits for polymorphism"
          - "Generics over trait objects when possible"
          - "Inline where beneficial"
        never:
          - "Box<dyn Trait> when generics work"
          - "Virtual dispatch without need"
        examples:
          good: |
            // Iterators compile to efficient loops
            let sum: i32 = data
                .iter()
                .filter(|x| **x > 0)
                .map(|x| x * 2)
                .sum();
            
            // Generic - monomorphized at compile time
            fn process<T: Display>(item: T) {
                println!("{}", item);
            }
          bad: |
            // Unnecessary dynamic dispatch
            fn process(item: &dyn Display) {
                println!("{}", item);
            }
        priority: 8

      - name: "Unsafe Minimization"
        rule: "Unsafe is a scalpel, not a sledgehammer"
        test: "Is unsafe absolutely necessary?"
        always:
          - "Safe wrappers around unsafe"
          - "Document invariants in comments"
          - "Minimize unsafe scope"
          - "Use safe abstractions from std"
        never:
          - "Unsafe to silence compiler"
          - "Raw pointers without justification"
          - "Unsafe without safety comment"
        examples:
          good: |
            /// # Safety
            /// Caller must ensure `ptr` is valid and properly aligned.
            unsafe fn dangerous(ptr: *const i32) -> i32 {
                *ptr
            }
            
            // Safe wrapper
            pub fn safe_read(slice: &[i32], index: usize) -> Option<i32> {
                slice.get(index).copied()
            }
          bad: |
            fn read_any(ptr: *const i32) -> i32 {
                unsafe { *ptr }  // No safety documentation!
            }
        priority: 9

      - name: "Pattern Matching Exhaustively"
        rule: "Handle all enum variants"
        always:
          - "Match all variants explicitly"
          - "Use #[non_exhaustive] for public enums"
          - "if let for single-variant matching"
        never:
          - "_ => {} for new variants"
          - "Silent catch-all in public API"
        priority: 8

      - name: "Clippy is Your Friend"
        rule: "cargo clippy -- -D warnings"
        always:
          - "Fix all clippy warnings"
          - "Use #[allow(clippy::...)] only with reason"
          - "Run clippy in CI"
        priority: 9

    anti_heuristics:
      - name: "Clone Happy"
        description: "Cloning to avoid borrow checker"
        triggers:
          - ".clone()"
          - "Rc<RefCell<"
          - "Arc<Mutex<"
        correction: "Reconsider ownership - borrow instead of clone"

      - name: "Unwrap Everywhere"
        description: "Using unwrap in production code"
        triggers:
          - ".unwrap()"
          - ".expect("
        correction: "Use ? for propagation, handle errors properly"

      - name: "Unsafe Abuse"
        description: "Using unsafe unnecessarily"
        triggers:
          - "unsafe {"
          - "raw pointer"
        correction: "Find safe alternative or document why unsafe is required"

    communication:
      tone:
        - Precise
        - Safety-conscious
        - Performance-aware
        - Educational
      structure: "Ownership Model → Safe Pattern → Example"

  # ==========================================================================
  # FRAMEWORK — Methodology
  # ==========================================================================

  framework:
    name: "Rust Safety Model"
    description: "Ownership, borrowing, and lifetimes"
    decision_tree: |
      Ask: "How should this data be handled?"
      
      Read only → &T (borrow)
      Read/write → &mut T (mutable borrow)
      Take ownership → T (move)
      Shared ownership → Arc<T> or Rc<T>
      Interior mutability → RefCell<T> or Mutex<T>

    categories:
      - name: "OWNERSHIP"
        purpose: "Memory management without GC"
        patterns:
          - "Move semantics"
          - "Borrowing"
          - "Lifetimes"
          - "Smart pointers"

      - name: "ERROR_HANDLING"
        purpose: "Recoverable errors"
        patterns:
          - "Result<T, E>"
          - "? operator"
          - "Custom error types"
          - "Error conversion"

      - name: "TRAITS"
        purpose: "Polymorphism and behavior"
        patterns:
          - "Trait bounds"
          - "Associated types"
          - "Default implementations"
          - "Trait objects"

  # ==========================================================================
  # PERSONAS — Adversarial Testing
  # ==========================================================================

  personas:
    - name: "borrow_checker"
      description: "The Rust compiler"
      background: "Enforcing ownership rules"
      goals:
        - "Prevent data races"
        - "Ensure memory safety"
        - "Enforce lifetimes"
      attack_vectors:
        - "Who owns this data?"
        - "How long does this reference live?"
        - "Is there aliasing mutation?"

    - name: "clippy"
      description: "Lint tool"
      background: "Finding common mistakes and improvements"
      goals:
        - "Idiomatic code"
        - "Performance improvements"
        - "Common pitfalls"
      attack_vectors:
        - "Is there a simpler way?"
        - "Is this clone necessary?"
        - "Is this match exhaustive?"

    - name: "fuzz_tester"
      description: "Testing with random inputs"
      background: "cargo-fuzz finding edge cases"
      goals:
        - "Find panics"
        - "Test error paths"
        - "Discover UB"
      attack_vectors:
        - "What if this is empty?"
        - "What if this overflows?"
        - "What about malformed input?"

  # ==========================================================================
  # VALIDATORS — Quality Gates
  # ==========================================================================

  validators:
    deterministic:
      - name: "cargo_clippy"
        script: "cargo clippy -- -D warnings"
        severity: "error"
        description: "No clippy warnings"

      - name: "cargo_check"
        script: "cargo check"
        severity: "error"
        description: "Code compiles"

      - name: "no_unwrap"
        script: "grep -rE '\\.unwrap\\(\\)' --include='*.rs' src/"
        severity: "warning"
        description: "No unwrap in production code"

    heuristic:
      - name: "errors_typed"
        check: "Errors use proper error types"
        method: "code_analysis"
        confidence_threshold: 0.85
        severity: "warning"

      - name: "unsafe_documented"
        check: "All unsafe blocks have safety comments"
        method: "code_analysis"
        confidence_threshold: 0.9
        severity: "error"

  # ==========================================================================
  # ROUTER — Intent and Skill Routing
  # ==========================================================================

  router:
    tiers:
      - level: 0
        name: "Quick Fix"
        triggers:
          - "typo"
          - "format"
          - "import"
        retrieval: false
        validation: false

      - level: 1
        name: "Standard"
        triggers: []
        retrieval: true
        validation: true

      - level: 2
        name: "Deep Review"
        triggers:
          - "unsafe audit"
          - "lifetime help"
          - "ownership"
        retrieval: true
        validation: true
        personas:
          - "borrow_checker"
          - "clippy"
        require_confirmation: true

    shortcuts:
      "::rs": "Rust best practices"
      "::own": "Ownership analysis"
      "::life": "Lifetime help"
      "::unsafe": "Unsafe audit"

  # ==========================================================================
  # SKILLS — Action Capabilities
  # ==========================================================================

  skills:
    - name: "rust-review"
      description: "Review Rust code"
      type: inline
      triggers:
        - "rust review"
        - "rustacean"
      instructions: |
        ## Goal
        Review code for Rust idioms and safety.
        
        ## Checklist
        - [ ] Ownership is clear
        - [ ] Errors use Result
        - [ ] No unnecessary clones
        - [ ] Unsafe is justified and documented
        - [ ] Clippy passes

    - name: "lifetime-help"
      description: "Explain and fix lifetime issues"
      type: inline
      triggers:
        - "lifetimes"
        - "borrow checker"
      instructions: |
        ## Goal
        Understand and fix lifetime errors.
        
        ## Process
        1. Identify what the compiler is saying
        2. Draw the lifetime relationships
        3. Determine if data outlives references
        4. Add lifetime annotations or restructure

    - name: "error-types"
      description: "Create proper error handling"
      type: inline
      triggers:
        - "rust errors"
        - "thiserror"
        - "anyhow"
      instructions: |
        ## Goal
        Implement proper error handling.
        
        ## Libraries
        - `thiserror` for library errors
        - `anyhow` for application errors
        
        ## Pattern
        ```rust
        #[derive(Error, Debug)]
        pub enum MyError {
            #[error("description: {0}")]
            Variant(String),
            #[error("io error")]
            Io(#[from] std::io::Error),
        }
        ```

  # ==========================================================================
  # SCANNER — State DAG Configuration
  # ==========================================================================

  scanner:
    type: rust
    description: "Scan Rust project"

    detect_markers:
      - Cargo.toml
      - Cargo.lock
      - "*.rs"

    health_probes:
      - name: "clippy_clean"
        description: "No clippy warnings"
        severity: "warning"

      - name: "unsafe_audited"
        description: "Unsafe blocks documented"
        severity: "warning"

  # ==========================================================================
  # QUALITY POLICY
  # ==========================================================================

  quality_policy:
    min_confidence: 0.85
    required_validators:
      - cargo_clippy
    persona_agreement: 0.5
    retry_limit: 2
