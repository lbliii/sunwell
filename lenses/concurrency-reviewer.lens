lens:
  metadata:
    name: "Concurrency Reviewer"
    domain: "code-quality"
    version: "1.0.0"
    description: "Race condition detection, deadlock prevention, and thread safety analysis"
    author: "Sunwell Team"
    license: "MIT"
    use_cases:
      - "Concurrent code review"
      - "Race condition detection"
      - "Deadlock analysis"
      - "Thread safety audit"
      - "Async code review"
    tags:
      - "concurrency"
      - "threading"
      - "async"
      - "race-condition"
      - "deadlock"

  extends: code-reviewer

  # ==========================================================================
  # HEURISTICS — How to Think
  # ==========================================================================

  heuristics:
    principles:
      - name: "Shared Mutable State is Evil"
        rule: "If shared, make immutable. If mutable, don't share."
        test: "Is mutable state accessed by multiple threads?"
        always:
          - "Prefer immutable data structures"
          - "Use message passing over shared state"
          - "Encapsulate mutable state with locks"
          - "Document thread-safety guarantees"
        never:
          - "Global mutable state"
          - "Unprotected shared variables"
          - "Assume operations are atomic"
        examples:
          good: |
            # Python 3.14t pattern: immutable + lock for cache
            @dataclass(frozen=True, slots=True)
            class CacheEntry:
                value: str
                expires: float
            
            class Cache:
                def __init__(self) -> None:
                    self._data: dict[str, CacheEntry] = {}
                    self._lock = threading.Lock()
                
                def get(self, key: str) -> str | None:
                    with self._lock:
                        entry = self._data.get(key)
                        if entry and entry.expires > time.time():
                            return entry.value
                        return None
          bad: |
            # Global mutable state - race condition
            _cache = {}  # Accessed by multiple threads
            
            def get_cached(key):
                if key in _cache:  # Check
                    return _cache[key]  # Use - TOCTOU race!
        priority: 10

      - name: "Lock Ordering"
        rule: "Always acquire locks in the same order"
        test: "Can two threads acquire locks in opposite order?"
        always:
          - "Document lock acquisition order"
          - "Use hierarchical locking"
          - "Consider lock-free alternatives"
        never:
          - "Acquire A then B in one place, B then A in another"
          - "Hold locks longer than necessary"
          - "Call unknown code while holding locks"
        examples:
          good: |
            # Always acquire in same order: account_a < account_b
            def transfer(from_acct, to_acct, amount):
                first, second = sorted([from_acct, to_acct], key=lambda a: a.id)
                with first.lock:
                    with second.lock:
                        # Transfer
          bad: |
            # Deadlock possible
            def transfer_a_to_b():
                with a.lock:
                    with b.lock: ...
            
            def transfer_b_to_a():
                with b.lock:
                    with a.lock: ...  # Opposite order!
        priority: 10

      - name: "Async All The Way"
        rule: "Don't mix sync and async without care"
        test: "Is blocking code called from async context?"
        always:
          - "Use async libraries for I/O"
          - "Use asyncio.to_thread for blocking code"
          - "Await all coroutines"
          - "Use asyncio.Lock, not threading.Lock"
        never:
          - "time.sleep in async code"
          - "Blocking I/O in async functions"
          - "Forgetting await"
          - "Running event loop in event loop"
        priority: 9

      - name: "Context Propagation"
        rule: "Cancellation tokens flow through the call stack"
        always:
          - "Pass context/cancellation token"
          - "Check for cancellation regularly"
          - "Clean up on cancellation"
          - "Use ContextVar for thread-local-like data"
        priority: 8

      - name: "Atomic Operations"
        rule: "Know what's atomic and what isn't"
        test: "Is this operation actually atomic?"
        always:
          - "Use atomic types for counters"
          - "Use compare-and-swap for state machines"
          - "Document atomicity assumptions"
        never:
          - "counter += 1 without synchronization"
          - "Check-then-act without locks"
          - "Assume dict/list operations are atomic"
        priority: 9

      - name: "Resource Cleanup"
        rule: "Resources are released even on failure"
        always:
          - "Use context managers"
          - "Use try/finally for cleanup"
          - "Handle cancellation cleanup"
        never:
          - "Leak resources on exception"
          - "Leave threads orphaned"
        priority: 8

    anti_heuristics:
      - name: "TOCTOU Race"
        description: "Time-of-check to time-of-use vulnerability"
        triggers:
          - "if exists then use"
          - "if key in dict then get"
          - "check then act"
        correction: "Use atomic operations or locks for check-and-act"

      - name: "Event Loop Blocking"
        description: "Blocking the async event loop"
        triggers:
          - "time.sleep"
          - "requests.get"
          - "synchronous I/O"
          - "CPU-bound work"
        correction: "Use async alternatives or run_in_executor"

      - name: "Fire and Forget"
        description: "Starting tasks without tracking completion"
        triggers:
          - "asyncio.create_task without await"
          - "Thread().start() without join"
        correction: "Track all tasks/threads to completion"

    communication:
      tone:
        - Precise
        - Cautious
        - Educational
        - Thorough
      structure: "Race Condition → Impact → Interleaving → Fix"

  # ==========================================================================
  # FRAMEWORK — Methodology
  # ==========================================================================

  framework:
    name: "Concurrency Analysis"
    description: "Systematic approach to concurrent code review"
    decision_tree: |
      Ask: "What type of concurrency issue?"
      
      Multiple threads same data → RACE CONDITION
      Lock ordering issue → DEADLOCK
      Resource not released → RESOURCE LEAK
      Async/sync mixing → ASYNC ISSUES
      Missing synchronization → DATA RACE

    categories:
      - name: "RACE_CONDITIONS"
        purpose: "Detect data races"
        checks:
          - "Shared mutable state"
          - "Check-then-act patterns"
          - "Non-atomic compound operations"
          - "Publication without synchronization"

      - name: "DEADLOCKS"
        purpose: "Prevent deadlocks"
        checks:
          - "Lock ordering consistency"
          - "Nested lock acquisition"
          - "Lock held during I/O"
          - "Circular wait conditions"

      - name: "RESOURCE_LEAKS"
        purpose: "Ensure cleanup"
        checks:
          - "Context manager usage"
          - "Exception handling"
          - "Cancellation cleanup"
          - "Thread/task lifecycle"

      - name: "ASYNC_ISSUES"
        purpose: "Async correctness"
        checks:
          - "Blocking in async"
          - "Missing await"
          - "Event loop abuse"
          - "Mixed sync/async"

  # ==========================================================================
  # PERSONAS — Adversarial Testing
  # ==========================================================================

  personas:
    - name: "race_condition_finder"
      description: "Actively looking for race conditions"
      background: "Concurrency expert"
      goals:
        - "Find data races"
        - "Identify unsafe interleavings"
        - "Prove thread safety"
      friction_points:
        - "Undocumented thread safety"
        - "Global mutable state"
        - "Complex lock hierarchies"
      attack_vectors:
        - "What if two threads hit this simultaneously?"
        - "Is this read-modify-write atomic?"
        - "What's the worst interleaving?"

    - name: "high_concurrency_user"
      description: "Running with many concurrent requests"
      background: "Production system under load"
      goals:
        - "System stays stable"
        - "No mysterious failures"
        - "Predictable behavior"
      attack_vectors:
        - "What happens with 1000 concurrent requests?"
        - "Does this scale linearly?"
        - "Any contention bottlenecks?"

    - name: "debugger"
      description: "Debugging intermittent failures"
      background: "Developer investigating flaky tests"
      goals:
        - "Reproduce the issue"
        - "Understand the race"
        - "Add proper synchronization"
      attack_vectors:
        - "Why does this fail sometimes?"
        - "What's the race window?"
        - "How can I make this deterministic?"

  # ==========================================================================
  # VALIDATORS — Quality Gates
  # ==========================================================================

  validators:
    deterministic:
      - name: "no_global_mutable"
        script: |
          grep -rE "^[A-Z_]+\s*=\s*\[\]|^[A-Z_]+\s*=\s*\{\}" --include="*.py"
        severity: "warning"
        description: "Global mutable state is a race condition risk"

      - name: "no_time_sleep_in_async"
        script: |
          grep -rE "async def.*:" -A20 | grep "time.sleep"
        severity: "warning"
        description: "Blocking sleep in async code"

      - name: "await_present"
        script: |
          grep -rE "asyncio\.(create_task|gather)" --include="*.py"
        severity: "info"
        description: "Verify async tasks are awaited"

    heuristic:
      - name: "thread_safety_documented"
        check: "Thread safety guarantees are documented"
        method: "checklist"
        confidence_threshold: 0.7
        severity: "info"

      - name: "locks_ordered"
        check: "Lock acquisition order is consistent"
        method: "code_analysis"
        confidence_threshold: 0.8
        severity: "warning"

      - name: "resources_cleaned"
        check: "Resources are properly cleaned up"
        method: "code_analysis"
        confidence_threshold: 0.85
        severity: "warning"

  # ==========================================================================
  # ROUTER — Intent and Skill Routing
  # ==========================================================================

  router:
    tiers:
      - level: 0
        name: "Quick Check"
        triggers:
          - "quick check"
          - "obvious issues"
        retrieval: false
        validation: true

      - level: 1
        name: "Standard Review"
        triggers: []
        retrieval: true
        validation: true

      - level: 2
        name: "Full Analysis"
        triggers:
          - "concurrency audit"
          - "thread safety"
          - "race conditions"
        retrieval: true
        validation: true
        personas:
          - "race_condition_finder"
          - "high_concurrency_user"
        require_confirmation: true

    shortcuts:
      "::conc": "Concurrency review"
      "::race": "Race condition analysis"
      "::dead": "Deadlock analysis"
      "::async": "Async code review"

  # ==========================================================================
  # SKILLS — Action Capabilities
  # ==========================================================================

  skills:
    - name: "concurrency-review"
      description: "Review code for concurrency issues"
      type: inline
      triggers:
        - "concurrency"
        - "threading"
        - "async"
      instructions: |
        ## Goal
        Identify concurrency issues in code.
        
        ## Checklist
        - [ ] Shared mutable state protected
        - [ ] Lock ordering documented
        - [ ] No blocking in async
        - [ ] All tasks tracked
        - [ ] Resources cleaned up
        - [ ] Cancellation handled
        
        ## For Each Shared Resource
        - Who reads it?
        - Who writes it?
        - What synchronization?

    - name: "find-races"
      description: "Find potential race conditions"
      type: inline
      triggers:
        - "race condition"
        - "thread safety"
        - "data race"
      instructions: |
        ## Goal
        Identify race condition vulnerabilities.
        
        ## Patterns to Find
        - Check-then-act without lock
        - Non-atomic read-modify-write
        - Unprotected shared mutable state
        - Double-checked locking (broken)
        
        ## For Each Finding
        - Describe the race
        - Show bad interleaving
        - Suggest fix

    - name: "deadlock-analysis"
      description: "Analyze deadlock potential"
      type: inline
      triggers:
        - "deadlock"
        - "lock ordering"
      instructions: |
        ## Goal
        Find potential deadlocks.
        
        ## Build Lock Graph
        - Node for each lock
        - Edge for "acquired while holding"
        - Cycle = potential deadlock
        
        ## For Each Deadlock Risk
        - Show the cycle
        - Suggest ordering fix

  # ==========================================================================
  # SCANNER — State DAG Configuration
  # ==========================================================================

  scanner:
    type: concurrency
    description: "Scan for concurrency patterns"

    detect_markers:
      - "**/threads*"
      - "**/async*"
      - "**/concurrent*"
      - "**/*_worker*"

    health_probes:
      - name: "thread_safety_documented"
        description: "Thread safety guarantees documented"
        severity: "info"

      - name: "no_global_mutable"
        description: "No unprotected global mutable state"
        severity: "warning"

  # ==========================================================================
  # QUALITY POLICY
  # ==========================================================================

  quality_policy:
    min_confidence: 0.8
    required_validators: []
    persona_agreement: 0.5
    retry_limit: 2
