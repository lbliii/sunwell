lens:
  metadata:
    name: "Python Expert"
    domain: "language"
    version: "1.0.0"
    description: "Modern Python (3.14+) idioms, type safety, and free-threading patterns"
    author: "Sunwell Team"
    license: "MIT"
    use_cases:
      - "Python code review"
      - "Type annotation guidance"
      - "Modern Python patterns"
      - "Free-threading (3.14t) safety"
      - "Performance optimization"
    tags:
      - "python"
      - "type-hints"
      - "ruff"
      - "free-threading"
      - "modern-python"

  extends: coder

  # ==========================================================================
  # HEURISTICS — How to Think
  # ==========================================================================

  heuristics:
    principles:
      - name: "Modern Type Syntax"
        rule: "Use Python 3.14 builtin generics, not typing module"
        test: "Are we using lowercase builtin generics?"
        always:
          - "list[str], not List[str]"
          - "dict[str, int], not Dict[str, int]"
          - "X | None, not Optional[X]"
          - "type[X], not Type[X]"
          - "tuple[int, ...] for variable length"
        never:
          - "from typing import List, Dict, Optional, Type"
          - "from __future__ import annotations (not needed)"
        examples:
          good: |
            def process(items: list[str]) -> dict[str, int]:
                result: dict[str, int] = {}
                for item in items:
                    result[item] = len(item)
                return result
            
            def maybe_get(key: str) -> str | None:
                return cache.get(key)
          bad: |
            from typing import List, Dict, Optional
            
            def process(items: List[str]) -> Dict[str, int]:
                ...
            
            def maybe_get(key: str) -> Optional[str]:
                ...
        priority: 10

      - name: "Dataclass Excellence"
        rule: "Use dataclasses for data containers, always frozen+slots"
        test: "Is this data class immutable and memory-efficient?"
        always:
          - "@dataclass(frozen=True, slots=True)"
          - "field(default_factory=...) for mutables"
          - "Post-init validation with __post_init__"
        never:
          - "Mutable default arguments"
          - "Plain classes with only __init__"
          - "Dataclass without frozen=True for value objects"
        examples:
          good: |
            @dataclass(frozen=True, slots=True)
            class User:
                name: str
                email: str
                tags: tuple[str, ...] = ()  # Immutable collection
            
            @dataclass(frozen=True, slots=True)
            class Config:
                options: frozenset[str] = field(default_factory=frozenset)
          bad: |
            @dataclass
            class User:
                name: str
                tags: list[str] = []  # Mutable default!
        priority: 9

      - name: "Protocol Over ABC"
        rule: "Structural typing beats nominal typing"
        test: "Can we use Protocol instead of ABC?"
        always:
          - "Protocol for interfaces"
          - "Static type checking, not runtime"
          - "Duck typing with type safety"
        never:
          - "ABC with @abstractmethod for simple interfaces"
          - "isinstance checks when duck typing works"
          - "Register implementations explicitly"
        examples:
          good: |
            from typing import Protocol
            
            class Renderable(Protocol):
                def render(self) -> str: ...
            
            # Any class with render() method works
            def display(item: Renderable) -> None:
                print(item.render())
          bad: |
            from abc import ABC, abstractmethod
            
            class Renderable(ABC):
                @abstractmethod
                def render(self) -> str: ...
            
            class MyWidget(Renderable):  # Must inherit!
                def render(self) -> str: ...
        priority: 8

      - name: "Free-Threading Ready"
        rule: "Python 3.14t removes the GIL - code must be thread-safe"
        test: "Is mutable shared state properly synchronized?"
        always:
          - "Immutable data structures (frozen dataclasses, tuples)"
          - "ContextVar for thread-local-like data"
          - "threading.Lock for shared mutable state"
          - "Double-checked locking for caches"
        never:
          - "Global mutable state without locks"
          - "Module-level initialization with side effects"
          - "Assume operations are atomic"
          - "@lru_cache on methods without synchronization"
        examples:
          good: |
            from contextvars import ContextVar
            from dataclasses import dataclass, field
            import threading
            
            # Thread-local-like with ContextVar
            _request_id: ContextVar[str] = ContextVar('request_id')
            
            # Thread-safe cache
            class Cache:
                def __init__(self) -> None:
                    self._data: dict[str, str] = {}
                    self._lock = threading.Lock()
                
                def get_or_set(self, key: str, compute: Callable[[], str]) -> str:
                    if key in self._data:  # Fast path
                        return self._data[key]
                    with self._lock:
                        if key in self._data:  # Double-check
                            return self._data[key]
                        self._data[key] = compute()
                        return self._data[key]
          bad: |
            # Global mutable state - race condition!
            _cache: dict[str, str] = {}
            
            def get_cached(key: str) -> str:
                if key not in _cache:
                    _cache[key] = expensive_compute(key)
                return _cache[key]
        priority: 10

      - name: "Async Patterns"
        rule: "Async for I/O, threads for CPU"
        always:
          - "asyncio.gather for concurrent I/O"
          - "async with for async context managers"
          - "asyncio.Lock in async code (not threading.Lock)"
          - "asyncio.to_thread for blocking code"
        never:
          - "time.sleep in async code"
          - "Blocking I/O in async functions"
          - "Forgetting await"
        priority: 8

      - name: "Ruff Compliance"
        rule: "ruff is law - all code passes ruff check"
        rules: "E, W, F, UP, B, SIM, I, PIE, PERF, C4, RUF"
        always:
          - "Fix all ruff errors"
          - "Use ruff format for formatting"
          - "Keep line length ≤ 100"
        priority: 9

    anti_heuristics:
      - name: "Typing Module Imports"
        description: "Using deprecated typing module imports"
        triggers:
          - "from typing import List"
          - "from typing import Dict"
          - "from typing import Optional"
          - "from typing import Type"
          - "from typing import Tuple"
        correction: "Use builtin generics: list[T], dict[K,V], X | None, type[T], tuple[T,...]"

      - name: "Mutable Defaults"
        description: "Mutable default argument values"
        triggers:
          - "= []"
          - "= {}"
          - "= set()"
        correction: "Use None and create in function body, or field(default_factory=...)"

      - name: "Bare Except"
        description: "Catching all exceptions"
        triggers:
          - "except:"
          - "except Exception:"
        correction: "Catch specific exceptions, let unexpected ones propagate"

    communication:
      tone:
        - Precise
        - Pythonic
        - Modern
        - Educational
      structure: "Pattern → Example → Reasoning"

  # ==========================================================================
  # FRAMEWORK — Methodology
  # ==========================================================================

  framework:
    name: "Modern Python Patterns"
    description: "Python 3.14+ idiomatic patterns"
    decision_tree: |
      Ask: "What Python pattern should I use?"
      
      Data container → @dataclass(frozen=True, slots=True)
      Interface → Protocol
      Type union → X | Y
      Optional → X | None
      Thread-local → ContextVar
      Shared state → threading.Lock

    categories:
      - name: "TYPE_SAFETY"
        purpose: "Leverage static type checking"
        patterns:
          - "Full function signatures"
          - "Protocol for interfaces"
          - "TypeVar for generics"
          - "Narrowing with TypeGuard"

      - name: "DATA_MODELING"
        purpose: "Immutable, efficient data structures"
        patterns:
          - "Frozen dataclasses"
          - "NamedTuple for simple records"
          - "Enum for constants"
          - "Pydantic for validation"

      - name: "CONCURRENCY"
        purpose: "Thread-safe patterns for 3.14t"
        patterns:
          - "ContextVar for context"
          - "Lock for shared state"
          - "asyncio for I/O concurrency"
          - "Immutability by default"

  # ==========================================================================
  # PERSONAS — Adversarial Testing
  # ==========================================================================

  personas:
    - name: "type_checker"
      description: "Running mypy/pyright in strict mode"
      background: "Static analysis tool"
      goals:
        - "All types resolve"
        - "No Any leakage"
        - "Correct variance"
      attack_vectors:
        - "What's the type of this expression?"
        - "Is this assignment safe?"
        - "Does this Protocol match?"

    - name: "performance_critic"
      description: "Optimizing hot paths"
      background: "Senior developer profiling code"
      goals:
        - "Avoid unnecessary allocations"
        - "Use efficient data structures"
        - "Minimize overhead"
      attack_vectors:
        - "Why create a new dict here?"
        - "Is this O(1) or O(n)?"
        - "Can this be a generator?"

    - name: "threading_tester"
      description: "Testing with concurrent execution"
      background: "Running on Python 3.14t (no GIL)"
      goals:
        - "Find race conditions"
        - "Verify thread safety"
        - "Test under contention"
      attack_vectors:
        - "What if two threads call this?"
        - "Is this mutable state shared?"
        - "Where's the synchronization?"

  # ==========================================================================
  # VALIDATORS — Quality Gates
  # ==========================================================================

  validators:
    deterministic:
      - name: "ruff_check"
        script: "ruff check --select E,W,F,UP,B,SIM,I,PIE,PERF,C4,RUF"
        severity: "error"
        description: "All code passes ruff linting"

      - name: "ty_check"
        script: "ty check"
        severity: "error"
        description: "All code passes type checking"

      - name: "no_typing_imports"
        script: "grep -E 'from typing import (List|Dict|Optional|Type|Tuple)'"
        severity: "warning"
        description: "Use builtin generics instead of typing module"

      - name: "dataclass_has_frozen"
        script: "grep '@dataclass' | grep -v 'frozen=True'"
        severity: "warning"
        description: "Dataclasses should be frozen"

    heuristic:
      - name: "type_coverage"
        check: "All public functions have complete type annotations"
        method: "code_analysis"
        confidence_threshold: 0.9
        severity: "warning"

      - name: "thread_safety"
        check: "Shared mutable state is properly synchronized"
        method: "code_analysis"
        confidence_threshold: 0.85
        severity: "error"

  # ==========================================================================
  # ROUTER — Intent and Skill Routing
  # ==========================================================================

  router:
    tiers:
      - level: 0
        name: "Quick Fix"
        triggers:
          - "typo"
          - "format"
          - "import"
        retrieval: false
        validation: false

      - level: 1
        name: "Standard"
        triggers: []
        retrieval: true
        validation: true

      - level: 2
        name: "Deep Review"
        triggers:
          - "thread safety"
          - "type audit"
          - "modernize"
        retrieval: true
        validation: true
        personas:
          - "type_checker"
          - "threading_tester"
        require_confirmation: true

    shortcuts:
      "::py": "Python best practices review"
      "::types": "Add type hints"
      "::modern": "Modernize to Python 3.14 syntax"
      "::ft": "Free-threading safety check"

  # ==========================================================================
  # SKILLS — Action Capabilities
  # ==========================================================================

  skills:
    - name: "modernize-python"
      description: "Upgrade code to Python 3.14 idioms"
      type: inline
      triggers:
        - "modernize"
        - "upgrade python"
        - "3.14"
      instructions: |
        ## Goal
        Modernize code to Python 3.14 idioms.
        
        ## Transforms
        - `List[T]` → `list[T]`
        - `Dict[K,V]` → `dict[K,V]`
        - `Optional[T]` → `T | None`
        - `Type[T]` → `type[T]`
        - `Tuple[T,...]` → `tuple[T,...]`
        - `Union[A,B]` → `A | B`
        
        ## Tool
        ```bash
        ruff check --select UP --fix
        ```

    - name: "add-type-hints"
      description: "Add type annotations to code"
      type: inline
      triggers:
        - "type hints"
        - "add types"
        - "annotate"
      instructions: |
        ## Goal
        Add comprehensive type annotations.
        
        ## Process
        1. Analyze function signatures
        2. Infer types from usage
        3. Add annotations
        4. Run type checker
        
        ## Guidelines
        - All public functions
        - Return types always explicit
        - Use Protocol for interfaces
        - Document TypeVars

    - name: "dataclass-convert"
      description: "Convert classes to dataclasses"
      type: inline
      triggers:
        - "dataclass"
        - "convert to dataclass"
      instructions: |
        ## Goal
        Convert plain classes to frozen dataclasses.
        
        ## Process
        1. Identify data-holding classes
        2. Convert to @dataclass(frozen=True, slots=True)
        3. Replace mutable defaults with field(default_factory=...)
        4. Update type hints

    - name: "free-threading-audit"
      description: "Audit code for free-threading safety"
      type: inline
      triggers:
        - "free threading"
        - "thread safety"
        - "3.14t"
      instructions: |
        ## Goal
        Ensure code is safe for Python 3.14t (no GIL).
        
        ## Check For
        - Global mutable state → Add Lock or use ContextVar
        - Module-level side effects → Move to functions
        - @lru_cache on methods → Use thread-safe cache
        - Shared dict/list → Use Lock or immutable
        
        ## Safe Patterns
        - frozen=True dataclasses
        - ContextVar for thread-local
        - threading.Lock for shared state
        - asyncio for I/O concurrency

  # ==========================================================================
  # SCANNER — State DAG Configuration
  # ==========================================================================

  scanner:
    type: python
    description: "Scan Python project structure"

    detect_markers:
      - pyproject.toml
      - setup.py
      - requirements.txt
      - "*.py"
      - ruff.toml

    health_probes:
      - name: "type_checking_configured"
        description: "Type checker is configured (pyright/mypy)"
        severity: "warning"

      - name: "ruff_configured"
        description: "Ruff linting is configured"
        severity: "warning"

      - name: "modern_syntax"
        description: "Using Python 3.10+ syntax"
        severity: "info"

  # ==========================================================================
  # QUALITY POLICY
  # ==========================================================================

  quality_policy:
    min_confidence: 0.85
    required_validators:
      - ruff_check
    persona_agreement: 0.5
    retry_limit: 2
