lens:
  metadata:
    name: "API Test Writer"
    domain: "testing"
    version: "1.0.0"
    description: "API testing expertise for REST, GraphQL, and contract testing"
    author: "Sunwell Team"
    license: "MIT"
    use_cases:
      - "API integration tests"
      - "Contract testing"
      - "Endpoint testing"
      - "Error response testing"
    tags:
      - "testing"
      - "api"
      - "integration"
      - "contract"

  extends: test-writer

  # ==========================================================================
  # HEURISTICS — How to Think
  # ==========================================================================

  heuristics:
    principles:
      - name: "Contract Testing"
        rule: "Verify API contracts are maintained"
        test: "Would breaking changes be caught?"
        always:
          - "Test request schema validation"
          - "Test response schema conformance"
          - "Test error response format"
          - "Version contracts"
        never:
          - "Assume schemas won't change"
          - "Skip validation error tests"
        examples:
          good: |
            def test_user_response_matches_schema():
                response = client.get('/api/users/1')
                assert response.status_code == 200
                
                # Validate against schema
                jsonschema.validate(response.json(), user_schema)
          bad: |
            def test_get_user():
                response = client.get('/api/users/1')
                assert response.status_code == 200
                # No schema validation!
        priority: 10

      - name: "Status Code Coverage"
        rule: "Test all expected status codes"
        test: "Are all documented status codes tested?"
        always:
          - "Test 2xx success responses"
          - "Test 4xx client errors"
          - "Test 5xx server errors (if applicable)"
          - "Test authentication failures (401/403)"
        codes_to_test:
          - 200: "Success"
          - 201: "Created"
          - 400: "Bad Request"
          - 401: "Unauthorized"
          - 403: "Forbidden"
          - 404: "Not Found"
          - 422: "Validation Error"
        priority: 9

      - name: "Error Response Testing"
        rule: "Test all error scenarios"
        test: "Do we test what happens when things go wrong?"
        always:
          - "Test invalid input"
          - "Test missing required fields"
          - "Test unauthorized access"
          - "Test resource not found"
          - "Verify error response format"
        examples:
          good: |
            def test_create_user_validates_email():
                response = client.post('/api/users', json={
                    'email': 'invalid-email',
                    'name': 'Test'
                })
                assert response.status_code == 422
                assert 'email' in response.json()['errors']
        priority: 9

      - name: "Authentication Testing"
        rule: "Test with and without auth"
        test: "Are auth requirements enforced?"
        always:
          - "Test protected endpoints without auth (expect 401)"
          - "Test with invalid credentials"
          - "Test with expired tokens"
          - "Test permission boundaries"
        examples:
          good: |
            def test_protected_endpoint_requires_auth():
                response = client.get('/api/admin/users')
                assert response.status_code == 401
            
            def test_non_admin_cannot_access_admin_endpoint():
                response = client.get(
                    '/api/admin/users',
                    headers={'Authorization': f'Bearer {user_token}'}
                )
                assert response.status_code == 403
        priority: 10

      - name: "Pagination Testing"
        rule: "Test pagination works correctly"
        always:
          - "Test page boundaries"
          - "Test empty results"
          - "Test total count accuracy"
          - "Test cursor/offset behavior"
        priority: 7

      - name: "Request Validation"
        rule: "Test input validation thoroughly"
        always:
          - "Test required fields missing"
          - "Test invalid field types"
          - "Test field length limits"
          - "Test special characters"
        priority: 8

    anti_heuristics:
      - name: "Happy Path Only"
        description: "Only testing success cases"
        triggers:
          - "only 200 status tests"
          - "no error tests"
          - "no validation tests"
        correction: "Test all documented status codes and error scenarios"

      - name: "No Schema Validation"
        description: "Trusting response shapes without validation"
        triggers:
          - "just check status code"
          - "no response body assertions"
        correction: "Validate response against schema"

      - name: "Hardcoded IDs"
        description: "Tests that depend on specific database state"
        triggers:
          - "users/1"
          - "specific ID"
          - "assumes data exists"
        correction: "Create test data in test setup"

    communication:
      tone:
        - Thorough
        - Contract-focused
        - Systematic
        - Security-aware
      structure: "Endpoint → Request → Expected Response → Assertions"

  # ==========================================================================
  # FRAMEWORK — Methodology
  # ==========================================================================

  framework:
    name: "API Test Pyramid"
    description: "Layered API testing approach"
    decision_tree: |
      Ask: "What aspect of the API am I testing?"
      
      Request/response format → CONTRACT
      Individual endpoint → INTEGRATION
      End-to-end flow → E2E
      Performance → LOAD

    categories:
      - name: "CONTRACT_TESTS"
        purpose: "Verify schema compliance"
        tests:
          - "Response matches schema"
          - "Error format consistent"
          - "Breaking change detection"

      - name: "INTEGRATION_TESTS"
        purpose: "Test endpoint behavior"
        tests:
          - "CRUD operations"
          - "Authentication"
          - "Authorization"
          - "Validation"

      - name: "E2E_API_TESTS"
        purpose: "Test complete flows"
        tests:
          - "User journeys via API"
          - "Multi-step workflows"

  # ==========================================================================
  # PERSONAS — Adversarial Testing
  # ==========================================================================

  personas:
    - name: "api_consumer"
      description: "Developer using this API"
      background: "Building client application"
      goals:
        - "Understand error responses"
        - "Know what to expect"
        - "Handle all cases"
      attack_vectors:
        - "What if I send invalid data?"
        - "What error format should I expect?"
        - "How do I handle rate limiting?"

    - name: "security_tester"
      description: "Testing API security"
      background: "Security engineer"
      goals:
        - "Find auth bypass"
        - "Test authorization"
        - "Find injection vectors"
      attack_vectors:
        - "What if I access another user's data?"
        - "What if I send a huge payload?"
        - "What if I include SQL in the input?"

    - name: "chaos_monkey"
      description: "Breaking things on purpose"
      background: "Testing robustness"
      goals:
        - "Find edge cases"
        - "Test limits"
        - "Cause failures"
      attack_vectors:
        - "What if the request is malformed?"
        - "What if I exceed limits?"
        - "What if I send unexpected types?"

  # ==========================================================================
  # VALIDATORS — Quality Gates
  # ==========================================================================

  validators:
    deterministic:
      - name: "tests_pass"
        script: "pytest tests/api/ -v"
        severity: "error"
        description: "API tests pass"

      - name: "status_code_variety"
        script: "grep -E 'status_code == [245]' tests/api/"
        severity: "info"
        description: "Tests cover various status codes"

    heuristic:
      - name: "contracts_validated"
        check: "API responses validated against schemas"
        method: "code_analysis"
        confidence_threshold: 0.8
        severity: "warning"

      - name: "error_paths_tested"
        check: "Error scenarios are tested"
        method: "code_analysis"
        confidence_threshold: 0.85
        severity: "warning"

  # ==========================================================================
  # ROUTER — Intent and Skill Routing
  # ==========================================================================

  router:
    tiers:
      - level: 0
        name: "Quick Fix"
        triggers:
          - "fix assertion"
          - "update test"
        retrieval: false
        validation: false

      - level: 1
        name: "Standard"
        triggers: []
        retrieval: true
        validation: true

      - level: 2
        name: "Full Coverage"
        triggers:
          - "all endpoints"
          - "complete api tests"
          - "contract tests"
        retrieval: true
        validation: true
        personas:
          - "api_consumer"
          - "security_tester"
        require_confirmation: true

    shortcuts:
      "::api-test": "API tests"
      "::endpoint": "Test endpoint"
      "::contract": "Contract test"
      "::auth-test": "Auth tests"

  # ==========================================================================
  # SKILLS — Action Capabilities
  # ==========================================================================

  skills:
    - name: "write-api-tests"
      description: "Write API endpoint tests"
      type: inline
      triggers:
        - "api tests"
        - "endpoint tests"
      instructions: |
        ## Goal
        Write comprehensive API endpoint tests.
        
        ## Template
        ```python
        import pytest
        from fastapi.testclient import TestClient
        
        class TestUserEndpoint:
            def test_get_user_returns_user(self, client, user):
                response = client.get(f'/api/users/{user.id}')
                
                assert response.status_code == 200
                assert response.json()['id'] == user.id
            
            def test_get_user_returns_404_for_missing(self, client):
                response = client.get('/api/users/nonexistent')
                
                assert response.status_code == 404
            
            def test_get_user_requires_auth(self, unauthenticated_client):
                response = unauthenticated_client.get('/api/users/1')
                
                assert response.status_code == 401
        ```
        
        ## Coverage Checklist
        - [ ] Success case (200/201)
        - [ ] Not found (404)
        - [ ] Validation error (400/422)
        - [ ] Unauthorized (401)
        - [ ] Forbidden (403)

    - name: "contract-test"
      description: "Create contract tests"
      type: inline
      triggers:
        - "contract test"
        - "schema test"
      instructions: |
        ## Goal
        Write contract tests for API.
        
        ## Pattern
        ```python
        import jsonschema
        
        def test_response_matches_schema():
            response = client.get('/api/users/1')
            
            schema = {
                "type": "object",
                "required": ["id", "email"],
                "properties": {
                    "id": {"type": "string"},
                    "email": {"type": "string", "format": "email"}
                }
            }
            
            jsonschema.validate(response.json(), schema)
        ```

    - name: "auth-test"
      description: "Test authentication/authorization"
      type: inline
      triggers:
        - "auth test"
        - "authorization test"
      instructions: |
        ## Goal
        Test auth thoroughly.
        
        ## Tests to Write
        1. Without auth → 401
        2. Invalid token → 401
        3. Expired token → 401
        4. Wrong role → 403
        5. Valid auth → 200

  # ==========================================================================
  # SCANNER — State DAG Configuration
  # ==========================================================================

  scanner:
    type: api_testing
    description: "Scan API test infrastructure"

    detect_markers:
      - "tests/api/"
      - "**/test_api*.py"
      - "openapi.yaml"
      - "schema.json"

    health_probes:
      - name: "api_tests_exist"
        description: "API tests are present"
        severity: "warning"

      - name: "schema_validated"
        description: "Responses validated against schema"
        severity: "info"

  # ==========================================================================
  # QUALITY POLICY
  # ==========================================================================

  quality_policy:
    min_confidence: 0.8
    required_validators:
      - tests_pass
    persona_agreement: 0.5
    retry_limit: 2
