{"task_id": "code-function-001", "timestamp": "2026-01-18T18:52:28.812276", "outputs": {"bare": {"condition": "bare", "content": "```python\nimport asyncio\nfrom functools import wraps\nimport random\nimport time\n\nclass RetryWithExponentialBackoff:\n    def __init__(self, max_retries: int = 3, base_delay: float = 1.0, max_delay: float = 60.0,\n                 exponential_base: float = 2.0, retry_on: tuple = (Exception,), logger=None):\n        self.max_retries = max_retries\n        self.base_delay = base_delay\n        self.max_delay = max_delay\n        self.exponential_base = exponential_base\n        self.retry_on = retry_on\n        self.logger = logger\n\n    def __call__(self, fn):\n        @wraps(fn)\n        async def wrapper(*args, **kwargs):\n            attempt = 1\n            delay = self.base_delay\n            while True:\n                try:\n                    return await fn(*args, **kwargs)\n                except self.retry_on[0] as error:\n                    if attempt >= self.max_retries:\n                        raise\n\n                    retry_reason_str = f\"{type(error).__name__}: {error}\"\n                    if self.logger is not None and isinstance(self.logger, asyncio.AbstractEventLoop):\n                        self.logger.error(f\"Retry: Attempt {attempt + 1}/{self.max_retries} ({retry_reason_str})\")\n                    elif attempt >= 3:\n                        raise\n\n                    await asyncio.sleep(delay)\n                    delay *= self.exponential_base\n                    if delay > self.max_delay:\n                        delay = self.max_delay\n                except Exception as e:\n                    if isinstance(self.logger, asyncio.AbstractEventLoop):\n                        self.logger.error(f\"Unexpected exception: {e}\")\n                    raise\n\n        return wrapper\n\n# Example usage:\n\nclass MyException(Exception): pass\n\n@RetryWithExponentialBackoff(max_retries=5, base_delay=1.0, max_delay=60.0)\nasync def my_task():\n    print(\"Starting task\")\n    await asyncio.sleep(2)\n\ntry:\n    loop = asyncio.get_event_loop()\n    future = loop.create_future()\n    loop.call_later(4, lambda: future.set_result(None))\n    result = await asyncio.wait_for(future, 10.0)\nexcept asyncio.TimeoutError as e:\n    print(\"Timeout occurred:\", e)", "tokens_input": 134, "tokens_output": 538, "latency_ms": 11637}, "flat": {"condition": "flat", "content": "```python\nimport time\nfrom typing import Callable, TypeVar, Generic\n\nT = TypeVar('T')\n\nclass RetryDecorator(Generic[T]):\n    def __init__(\n        self,\n        func: Callable[..., T],\n        *,\n        max_retries: int = 3,\n        base_delay: float = 1.0,\n        max_delay: float = 60.0,\n        exponential_base: float = 2.0,\n        retry_on: tuple[type[Exception], ...] = Exception,\n    ):\n        self.func = func\n        self.max_retries = max_retries\n        self.base_delay = base_delay\n        self.max_delay = max_delay\n        self.exponential_base = exponential_base\n        self.retry_on = retry_on\n\n    def __call__(self, *args: tuple[Any], **kwargs: dict[str, Any]) -> Callable[..., T]:\n        @functools.wraps(self.func)\n        async def wrapper(*args: tuple[Any], **kwargs: dict[str, Any]) -> T:\n            attempt = 0\n            while True:\n                try:\n                    return await self.func(*args, **kwargs)\n                except self.retry_on as e:\n                    if attempt >= max_retries:\n                        raise\n\n                    delay = base_delay * (exponential_base ** attempt)\n                    print(f\"Attempt {attempt+1}/{max_retries}: Error caught: {e}. Retrying in {delay} seconds...\")\n                    await asyncio.sleep(delay)\n                    attempt += 1\n        return wrapper\n\n    def __call__(self, *args: tuple[Any], **kwargs: dict[str, Any]) -> Callable[..., T]:\n        @functools.wraps(self.func)\n        async def wrapper(*args: tuple[Any], **kwargs: dict[str, Any]) -> T:\n            attempt = 0\n            while True:\n                try:\n                    return await self.func(*args, **kwargs)\n                except self.retry_on as e:\n                    if attempt >= max_retries:\n                        raise\n\n                    delay = base_delay * (exponential_base ** attempt)\n                    print(f\"Attempt {attempt+1}/{max_retries}: Error caught: {e}. Retrying in {delay} seconds...\")\n                    await asyncio.sleep(delay)\n                    attempt += 1\n        return wrapper\n\n    def __call__(self, *args: tuple[Any], **kwargs: dict[str, Any]) -> Callable[..., T]:\n        @functools.wraps(self.func)\n        async def wrapper(*args: tuple[Any], **kwargs: dict[str, Any]) -> T:\n            attempt = 0\n            while True:\n                try:\n                    return await self.func(*args, **kwargs)\n                except self.retry_on as e:\n                    if attempt >= max_retries:\n                        raise\n\n                    delay = base_delay * (exponential_base ** attempt)\n                    print(f\"Attempt {attempt+1}/{max_retries}: Error caught: {e}. Retrying in {delay} seconds...\")\n                    await asyncio.sleep(delay)\n                    attempt += 1\n        return wrapper\n\n    def __call__(self, *args: tuple[Any], **kwargs: dict[str, Any]) -> Callable[..., T]:\n        @functools.wraps(self.func)\n        async def wrapper(*args: tuple[Any], **kwargs: dict[str, Any]) -> T:\n            attempt = 0\n            while True:\n                try:\n                    return await self.func(*args, **kwargs)\n                except self.retry_on as e:\n                    if attempt >= max_retries:\n                        raise\n\n                    delay = base_delay * (exponential_base ** attempt)\n                    print(f\"Attempt {attempt+1}/{max_retries}: Error caught: {e}. Retrying in {delay} seconds...\")\n                    await asyncio.sleep(delay)\n                    attempt += 1\n        return wrapper\n\n    def __call__(self, *args: tuple[Any], **kwargs: dict[str, Any]) -> Callable[..., T]:\n        @functools.wraps(self.func)\n        async def wrapper(*args: tuple[Any], **kwargs: dict[str, Any]) -> T:\n            attempt = 0\n            while True:\n                try:\n                    return await self.func(*args, **kwargs)\n                except self.retry_on as e:\n                    if attempt >= max_retries:\n                        raise\n\n                    delay = base_delay * (exponential_base ** attempt)\n                    print(f\"Attempt {attempt+1}/{max_retries}: Error caught: {e}. Retrying in {delay} seconds...\")\n                    await asyncio.sleep(delay)\n                    attempt += 1\n        return wrapper\n\n    def __call__(self, *args: tuple[Any], **kwargs: dict[str, Any]) -> Callable[..., T]:\n        @functools.wraps(self.func)\n        async def wrapper(*args: tuple[Any], **kwargs: dict[str, Any]) -> T:\n            attempt = 0\n            while True:\n                try:\n                    return await self.func(*args, **kwargs)\n                except self.retry_on as e:\n                    if attempt >= max_retries:\n                        raise\n\n                    delay = base_delay * (exponential_base ** attempt)\n                    print(f\"Attempt {attempt+1}/{max_retries}: Error caught: {e}. Retrying in {delay} seconds...\")\n                    await asyncio.sleep(delay)\n                    attempt += 1\n        return wrapper\n\n    def __call__(self, *args: tuple[Any], **kwargs: dict[str, Any]) -> Callable[..., T]:\n        @functools.wraps(self.func)\n        async def wrapper(*args: tuple[Any], **kwargs: dict[str, Any]) -> T:\n            attempt = 0\n            while True:\n                try:\n                    return await self.func(*args, **kwargs)\n                except self.retry_on as e:\n                    if attempt >= max_retries:\n                        raise\n\n                    delay = base_delay * (exponential_base ** attempt)\n                    print(f\"Attempt {attempt+1}/{max_retries}: Error caught: {e}. Retrying in {delay} seconds...\")\n                    await asyncio.sleep(delay)\n                    attempt += 1\n        return wrapper\n\n    def __call__(self, *args: tuple[Any], **kwargs: dict[str, Any]) -> Callable[..., T]:\n        @functools.wraps(self.func)\n        async def wrapper(*args: tuple[Any], **kwargs: dict[str, Any]) -> T:\n            attempt = 0\n            while True:\n                try:\n                    return await self.func(*args, **kwargs)\n                except self.retry_on as e:\n                    if attempt >= max_retries:\n                        raise\n\n                    delay = base_delay * (exponential_base ** attempt)\n                    print(f\"Attempt {attempt+1}/{max_retries}: Error caught: {e}. Retrying in {delay} seconds...\")\n                    await asyncio.sleep(delay)\n                    attempt += 1\n        return wrapper\n\n    def __call__(self, *args: tuple[Any], **kwargs: dict[str, Any]) -> Callable[..., T]:\n        @functools.wraps(self.func)\n        async def wrapper(*args: tuple[Any], **kwargs: dict[str, Any]) -> T:\n            attempt = 0\n            while True:\n                try:\n                    return await self.func(*args, **kwargs)\n                except self.retry_on as e:\n                    if attempt >= max_retries:\n                        raise\n\n                    delay = base_delay * (exponential_base ** attempt)\n                    print(f\"Attempt {attempt+1}/{max_retries}: Error caught: {e}. Retrying in {delay} seconds...\")\n                    await asyncio.sleep(delay)\n                    attempt += 1\n        return wrapper\n\n    def __call__(self, *args: tuple[Any], **kwargs: dict[str, Any]) -> Callable[..., T]:\n        @functools.wraps(self.func)\n        async def wrapper(*args: tuple[Any], **kwargs: dict[str, Any]) -> T:\n            attempt = 0\n            while True:\n                try:\n                    return await self.func(*args, **kwargs)\n                except self.retry_on as e:\n                    if attempt >= max_retries:\n                        raise\n\n                    delay = base_delay * (exponential_base ** attempt)\n                    print(f\"Attempt {attempt+1}/{max_retries}: Error caught: {e}. Retrying in {delay} seconds...\")\n                    await asyncio.sleep(delay)\n                    attempt += 1\n        return wrapper\n\n    def __call__(self, *args: tuple[Any], **kwargs: dict[str, Any]) -> Callable[..., T]:\n        @functools.wraps(self.func)\n        async def wrapper(*args: tuple[Any], **kwargs: dict[str, Any]) -> T:\n            attempt = 0\n            while True:\n                try:\n                    return await self.func(*args, **kwargs)\n                except self.retry_on as e:\n                    if attempt >= max_retries:\n                        raise\n\n                    delay = base_delay * (exponential_base ** attempt)\n                    print(f\"Attempt {attempt+1}/{max_retries}: Error caught: {e}. Retrying in {delay} seconds...\")\n                    await asyncio.sleep(delay)\n                    attempt += 1\n        return wrapper\n\n    def __call__(self, *args: tuple[Any], **kwargs: dict[str, Any]) -> Callable[..., T]:\n        @functools.wraps(self.func)\n        async def wrapper(*args: tuple[Any], **kwargs: dict[str, Any]) -> T:\n            attempt = 0\n            while True:\n                try:\n                    return await self.func(*args, **kwargs)\n                except self.retry_on as e:\n                    if attempt >= max_retries:\n                        raise\n\n                    delay = base_delay * (exponential_base ** attempt)\n                    print(f\"Attempt {attempt+1}/{max_retries}: Error caught: {e}. Retrying in {delay} seconds...\")\n                    await asyncio.sleep(delay)\n                    attempt += 1\n        return wrapper\n\n    def __call__(self, *", "tokens_input": 2399, "tokens_output": 2386, "latency_ms": 52314}, "selective": {"condition": "selective", "content": "```python\nimport time\nimport asyncio\nfrom functools import wraps\nfrom typing import (\n    Optional,\n    Union,\n    TYPE_CHECKING, Tuple,\n)\n\nif TYPE_CHECKING:\n    from typing_extensions import ParamSpec  # for type: only\n\n_P = ParamSpec(\"_P\")\n\n# Retry decorator with exponential backoff and jitter.\ndef retry(\n        max_retries: int = 3,\n        base_delay: float = 1.0,\n        max_delay: float = 60.0,\n        exponential_base: float = 2.0,\n        retry_on: Tuple[ExceptionType, ...] = (Exception,),\n) -> callable:\n    \"\"\"Decorator to apply a retry strategy with exponential backoff.\n    \n    This function rethrows any exceptions raised by the wrapped function\n    on each attempt if they match the `retry_on` types.\n\n    Args:\n        max_retries: Maximum number of retries. Defaults to 3 (default).\n        base_delay: Initial delay before first attempt. Defaults to 1.0.\n        max_delay: Maximum delay cap for any retry attempts. Defaults to 60.0.\n        exponential_base: Multiplier for backoff on each retry. Defaults to 2.0.\n        retry_on: Exception types that trigger retries. Defaults to `Exception`.\n\n    Returns:\n        A callable function with the same signature as the decorated one.\n\n    Example use cases:\n    \n    ```python\n    @retry(max_retries=3, base_delay=1.0, max_delay=60)\n    async def fetch_data():\n        # Simulate a potentially slow network request.\n        await asyncio.sleep(2)\n\n    try:\n        fetch_data()\n    except Exception as e:\n        print(f\"Failed to retrieve data: {e}\")\n        raise\n\n    ```\n    \n    ```python\n    @retry(max_retries=3, base_delay=1.0, max_delay=60)\n    def get_user_profile(user_id):\n        # Simulate a potentially slow database query.\n        time.sleep(2)\n\n    try:\n        user = get_user_profile(123)\n    except Exception as e:\n        print(f\"Failed to retrieve user profile: {e}\")\n        raise\n    ```\n    \n    ```python\n    @retry(max_retries=5, base_delay=0.5, max_delay=60, exponential_base=2.5)\n    def connect_to_db():\n        # Simulate a potentially slow database connection.\n        time.sleep(3)\n\n    try:\n        connect_to_db()\n    except Exception as e:\n        print(f\"Failed to connect to database: {e}\")\n        raise\n    ```\n    \n    \"\"\"\n    if not isinstance(max_retries, int) or max_retries < 0:\n        raise ValueError(\"max_retries must be an integer >= 0\")\n\n    base_delay = max(base_delay, 1.0)\n    max_delay = min(max_delay, 60.0)\n\n    # Calculate the exponential backoff multiplier.\n    delay_multiplier = exponentiate(exponential_base, -int(-max_retries))\n\n    @wraps(_)\n    def wrapped_retry_decorator(func: callable) -> callable:\n        \"\"\"Function to apply retry strategy.\"\"\"\n        @wraps(func)\n        async def wrapper(*args: _P.args, **kwargs: _P.kwargs):\n            if asyncio.iscoroutinefunction(func):\n                try:\n                    while True:\n                        await func(*args, **kwargs)\n                        break\n                except Exception as e:\n                    raise NewException(e) from None\n\n            else:\n                for attempt in range(1, max_retries + 1):\n                    delay = base_delay * delay_multiplier**attempt\n                    print(f\"Attempt {attempt} of {max_retries}: Waiting {delay:.2f}s...\")\n                    await asyncio.sleep(delay)\n\n        return wrapper\n\n    wrapped_retry_decorator.__doc__ = f\"\"\"\\\n@{wrapped_retry_decorator.__name__}\nRetry with exponential backoff and jitter.\n    \nArgs:\n    max_retries: Maximum number of retries. Defaults to 3 (default).\n    base_delay: Initial delay before first attempt. Defaults to 1.0.\n    max_delay: Maximum delay cap for any retry attempts. Defaults to 60.0.\n    exponential_base: Multiplier for backoff on each retry. Defaults to 2.0.\n    retry_on: Exception types that trigger retries. Defaults to `Exception`.\n\nReturns:\n    A callable function with the same signature as the decorated one.\n\nRaises:\n    TypeError: If max_retries is not an integer >= 0\n\"\"\"\n\n    return wrapped_retry_decorator\n\nclass NewException(Exception):\n    \"\"\"Custom exception for handling exceptions in retry strategy.\"\"\"\n    def __init__(self, *args, **kwargs) -> None:\n        super().__init__(*args, **kwargs)\n\n    def __str__(self) -> str:\n        if self.args and isinstance(self.args[0], Exception):\n            return f\"{type(self)}: {self.args[0]}\"\n        else:\n            return super().__str__()\n\n    __repr__ = __str__\n\ndef exponentiate(base: float, power: float) -> float:\n    \"\"\"Calculate the exponential of a base with a given power.\"\"\"\n    if power < 0.0 or not isinstance(power, (int, float)):\n        raise ValueError(\"power must be a non-negative integer\")\n\n    result = 1\n    for _ in range(int(-power)):\n        result *= base\n\n    return result\n```", "tokens_input": 314, "tokens_output": 1197, "latency_ms": 26110}, "self_directed": {"condition": "self_directed", "content": "Great! The first step is to ensure you're following best practices when handling retries. Let's start by crafting a simple retry decorator that catches specific exceptions and provides context in error messages for better debugging and resource management.\n\nHere\u2019s how I would approach it:\n\n1. **Catch Specific Exceptions**: Use `try...except` blocks with meaningful exception types.\n2. **Use Exception Chaining**: Raise a new, more specific exception to provide clearer context.\n3. **Provide Context in Error Messages**: Include the original error message within your custom error message.\n\nLet's implement this retry decorator pattern now:\n```python\ndef retry_with_backoff(fn):\n    attempts = 0\n\n    def wrapper(*args, **kwargs):\n        nonlocal attempts\n        while True:\n            try:\n                return fn(*args, **kwargs)\n            except Exception as e:\n                if attempts >= max_attempts or isinstance(e, expected_exception_types):\n                    raise\n                else:\n                    attempts += 1\n                    print(f\"Attempt {attempts} failed. Retrying... ({e.__class__.__name__})\")\n                    time.sleep(attempt_sleep_time)\n\n    return wrapper\n\n\n# Example usage and verification\n@retry_with_backoff\ndef critical_function():\n    # Simulate a potentially failing function call\n    raise ValueError(\"An unexpected error occurred.\")\n\ntry:\n    critical_function()\nexcept Exception as e:\n    print(f\"Caught an exception: {e}\")\n```\n\nThis implementation follows the best practices you've outlined. It catches specific exceptions, chains them when necessary (to provide more context), and logs additional information for debugging.\n\nLet's run this code snippet through `verify_against_expertise(code)` to ensure it adheres to the provided heuristics:\n\n```python\n# Run the verification:\nverify_against_expertise('code', {'code': 'from functools import wraps\\n\\ndef retry_with_backoff(fn):\\n    attempts = 0\\n\\n    def wrapper(*args, **kwargs):\\n        nonlocal attempts\\n        while True:\\n            try:\\n                return fn(*args, **kwargs)\\n            except Exception as e:\\n                if attempts >= max_attempts or isinstance(e, expected_exception_types):\\n                    raise\\n                else:\\n                    attempts += 1\\n                    print(f\"Attempt {attempts} failed. Retrying... ({e.__class__.__name__})\")\\n                    time.sleep(attempt_sleep_time)\\n\\n    return wrapper'})\n```\n\nIf everything is fine with your solution, you can proceed to write the code for your actual function or task. If there are any issues found during verification, make necessary adjustments based on the insights provided by `verify_against_expertise`.", "tokens_input": 502, "tokens_output": 698, "latency_ms": 13010}, "prefetch": {"condition": "prefetch", "content": "```python\nfrom typing import Awaitable, Callable, Dict, Optional\nimport asyncio\nimport time\nfrom functools import wraps\nfrom dataclasses import dataclass\n\n\n@dataclass(frozen=True)\nclass RetryOptions:\n    max_retries: int = 3\n    base_delay: float = 1.0\n    max_delay: float = 60.0\n    exponential_base: float = 2.0\n    retry_on: tuple[type[Exception]] = (Exception,)\n\n\ndef _retry_with_jitter(max_retries: int,\n                       base_delay: float,\n                       max_delay: float,\n                       exponential_base: float,\n                       retry_on: tuple[type[Exception]]) -> Callable[[Callable], Awaitable]:\n    def decorator(func: Callable) -> Awaitable:\n        @wraps(func)\n        async def wrapper(*args, **kwargs):\n            retries = 0\n            while True:\n                try:\n                    return await func(*args, **kwargs)\n                except retry_on as e:\n                    if retries >= max_retries:\n                        raise e from None\n                    delay = base_delay * (retries + 1) ** exponential_base\n                    if delay > max_delay:\n                        raise RuntimeError(\"Exceeding maximum delay\") from None\n                    await asyncio.sleep(delay)\n                    retries += 1\n\n        return wrapper\n\n    return decorator\n\n\nclass AsyncRetry:\n    def __init__(self, options: RetryOptions):\n        self.options = options\n\n    async def __call__(self, func: Callable) -> Awaitable:\n        @wraps(func)\n        async def wrapped(*args, **kwargs):\n            try:\n                return await func(*args, **kwargs)\n            except Exception as e:\n                if isinstance(e, (self.options.retry_on or [Exception])):\n                    raise\n\n        return wrapped\n\n\nasync def retry_with_exponential_backoff(\n    max_retries: int = 3,\n    base_delay: float = 1.0,\n    max_delay: float = 60.0,\n    exponential_base: float = 2.0,\n    retry_on: tuple[type[Exception]] = (Exception,),\n) -> Awaitable:\n    options = RetryOptions(\n        max_retries=max_retries,\n        base_delay=base_delay,\n        max_delay=max_delay,\n        exponential_base=exponential_base,\n        retry_on=retry_on,\n    )\n    return await _retry_with_jitter(options)(AsyncRetry(options))(options.options['retry_on'] if 'retry_on' in options else (Exception,))\n\n\ndef test_retry_decorator() -> None:\n    @RetryOptions(max_retries=2, base_delay=1.0, max_delay=5.0)\n    async def example_function() -> str:\n        raise ValueError(\"This should be retried\")\n\n    await retry_with_exponential_backoff(example_function())\n```", "tokens_input": 914, "tokens_output": 649, "latency_ms": 15145}}, "self_directed_metrics": {"total_tool_calls": 1, "list_expertise_calls": 0, "get_expertise_calls": 1, "verify_calls": 0, "topics_queried": ["retry decorator patterns"], "heuristics_retrieved": 1, "verification_passed": null, "react_iterations": 2, "tool_latency_ms": 19, "used_expertise_tools": true, "followed_react_pattern": false}, "prefetch_metrics": {"topics_detected": ["Type Safety First", "Error Handling", "Async Patterns"], "expertise_items": 3, "max_relevance_score": 0.8999999999999999, "min_relevance_score": 0.8, "prefetch_latency_ms": 0, "threshold_used": 0.5, "prompt_expansion_tokens": 780, "reasoning": "Expertise selected by semantic similarity:\n  - Type Safety First: 90% match\n  - Error Handling: 90% match\n  - Async Patterns: 80% match", "found_relevant_expertise": true}}
