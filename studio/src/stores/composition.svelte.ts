/**
 * Composition Store — Speculative UI composition state (RFC-082)
 *
 * Manages speculative UI composition that enables instant skeleton rendering
 * while content is still being generated by the LLM.
 *
 * Flow:
 * 1. User types input
 * 2. predict() called → fast Tier 0/1 prediction
 * 3. SkeletonLayout renders instantly
 * 4. Content streams in, replacing skeleton
 */

import { invoke } from '@tauri-apps/api/core';

// ═══════════════════════════════════════════════════════════════
// TYPES
// ═══════════════════════════════════════════════════════════════

export type PageType = 'home' | 'project' | 'research' | 'planning' | 'conversation';
export type InputMode = 'hero' | 'chat' | 'search' | 'command' | 'hidden';
export type CompositionSource = 'regex' | 'fast_model' | 'large_model' | 'default';

export interface PanelSpec {
	panel_type: string;
	title?: string;
	data?: Record<string, unknown>;
}

export interface CompositionSpec {
	page_type: PageType;
	panels: PanelSpec[];
	input_mode: InputMode;
	suggested_tools: string[];
	confidence: number;
	source: CompositionSource;
}

// ═══════════════════════════════════════════════════════════════
// STATE
// ═══════════════════════════════════════════════════════════════

interface CompositionState {
	/** Current composition spec */
	current: CompositionSpec | null;

	/** Is prediction in progress */
	isPredicting: boolean;

	/** Last prediction time (ms) */
	lastPredictionTime: number;

	/** Prediction history for pattern learning */
	history: Array<{
		input: string;
		composition: CompositionSpec;
		timestamp: number;
	}>;

	/** Error state */
	error: string | null;
}

function createInitialState(): CompositionState {
	return {
		current: null,
		isPredicting: false,
		lastPredictionTime: 0,
		history: [],
		error: null,
	};
}

export let compositionState = $state<CompositionState>(createInitialState());

// ═══════════════════════════════════════════════════════════════
// ACTIONS
// ═══════════════════════════════════════════════════════════════

/**
 * Predict UI composition for user input.
 *
 * This is called as soon as user types, before LLM generation starts.
 * Returns fast (50-200ms) to enable immediate skeleton rendering.
 */
export async function predict(
	input: string,
	currentPage: PageType = 'home'
): Promise<CompositionSpec | null> {
	if (!input.trim()) {
		compositionState.current = null;
		return null;
	}

	compositionState.isPredicting = true;
	compositionState.error = null;

	const startTime = performance.now();

	try {
		// Call Rust/Python via Tauri
		const result = await invoke<CompositionSpec | null>('predict_composition', {
			input,
			currentPage,
		});

		compositionState.lastPredictionTime = performance.now() - startTime;

		if (result) {
			compositionState.current = result;

			// Add to history for pattern learning
			compositionState.history = [
				...compositionState.history.slice(-49), // Keep last 50
				{
					input,
					composition: result,
					timestamp: Date.now(),
				},
			];

			return result;
		}

		return null;
	} catch (e) {
		const errorMessage = e instanceof Error ? e.message : String(e);
		compositionState.error = errorMessage;
		console.error('Composition prediction failed:', e);
		return null;
	} finally {
		compositionState.isPredicting = false;
	}
}

/**
 * Set composition directly (e.g., from large model response).
 */
export function setComposition(spec: CompositionSpec): void {
	compositionState.current = spec;
}

/**
 * Clear current composition.
 */
export function clearComposition(): void {
	compositionState.current = null;
}

/**
 * Reset to initial state.
 */
export function resetComposition(): void {
	Object.assign(compositionState, createInitialState());
}

// ═══════════════════════════════════════════════════════════════
// DERIVED STATE
// ═══════════════════════════════════════════════════════════════

/**
 * Check if we have a high-confidence prediction.
 */
export function hasHighConfidencePrediction(): boolean {
	return (compositionState.current?.confidence ?? 0) >= 0.8;
}

/**
 * Get panels from current composition.
 */
export function getPanels(): PanelSpec[] {
	return compositionState.current?.panels ?? [];
}

/**
 * Get input mode from current composition.
 */
export function getInputMode(): InputMode {
	return compositionState.current?.input_mode ?? 'hero';
}

/**
 * Get suggested tools from current composition.
 */
export function getSuggestedTools(): string[] {
	return compositionState.current?.suggested_tools ?? [];
}

// ═══════════════════════════════════════════════════════════════
// PATTERN ANALYSIS (for Phase 6)
// ═══════════════════════════════════════════════════════════════

interface PatternStats {
	totalPredictions: number;
	averagePredictionTime: number;
	panelFrequency: Record<string, number>;
	pageTypeFrequency: Record<string, number>;
}

/**
 * Analyze composition history for patterns.
 */
export function analyzePatterns(): PatternStats {
	const history = compositionState.history;

	if (history.length === 0) {
		return {
			totalPredictions: 0,
			averagePredictionTime: 0,
			panelFrequency: {},
			pageTypeFrequency: {},
		};
	}

	const panelFrequency: Record<string, number> = {};
	const pageTypeFrequency: Record<string, number> = {};

	for (const entry of history) {
		// Count page types
		const pageType = entry.composition.page_type;
		pageTypeFrequency[pageType] = (pageTypeFrequency[pageType] ?? 0) + 1;

		// Count panels
		for (const panel of entry.composition.panels) {
			panelFrequency[panel.panel_type] = (panelFrequency[panel.panel_type] ?? 0) + 1;
		}
	}

	return {
		totalPredictions: history.length,
		averagePredictionTime: compositionState.lastPredictionTime,
		panelFrequency,
		pageTypeFrequency,
	};
}
