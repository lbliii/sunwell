---
description: Convert RFC into actionable tasks grouped by subsystem with pre-drafted commits
alwaysApply: false
globs: ["plan/**/*.md"]
---

# Plan

Convert approved RFC into actionable, atomic task list.

**Shortcut**: `::plan`

**Works with**: `modules/evidence-handling`, `modules/types-as-contracts`

---

## RFC Lifecycle Position

```
plan/drafted/    →    plan/evaluated/    →    plan/ready/    →    DELETE
                           ↑                      ↑
                      ::rfc-eval               ::plan
```

---

## Prerequisites

- RFC must be in `plan/evaluated/` (passed `::rfc-eval`)
- Confidence ≥ 85%
- No unresolved critical issues

---

## Procedure

### Step 1: Analyze RFC

Extract from the approved RFC:
- Recommended approach
- Architecture impact table
- Implementation plan outline
- Estimated effort

### Step 2: Define Type Contracts First

For each new component, define types before implementation tasks:

```python
# Task 1.1 is ALWAYS: Define types/contracts
@dataclass(frozen=True)
class NewComponent:
    """The contract - defines expected structure."""
    field: Type
```

### Step 3: Group Tasks by Subsystem

```yaml
subsystems:
  core:      bengal/core/
  orch:      bengal/orchestration/
  render:    bengal/rendering/
  cache:     bengal/cache/
  health:    bengal/health/
  cli:       bengal/cli/
  tests:     tests/
```

### Step 4: Order by Dependencies

```
Types → Implementation → Integration Wiring → Verification
```

### Step 5: Pre-Draft Commits

Each task gets a commit message following Bengal conventions:

```bash
git add -A && git commit -m "<scope>: <what changed>"
```

---

## Output Format

```markdown
# Plan: [Feature Name]

**RFC**: `plan/evaluated/rfc-[name].md`
**Status**: Ready
**Created**: [date]
**Estimated Effort**: [N] hours

---

## Overview

[2-3 sentences: what this plan delivers, key phases]

---

## Phase 1: Type Contracts

Define types before implementation (Bengal philosophy: types as contracts).

### Task 1.1: Define [Component] Type Contract

**Subsystem**: Core
**File**: `bengal/core/[component].py`

**Changes**:
```python
@dataclass(frozen=True)
class NewContract:
    """Immutable contract for [purpose]."""
    field: Type
```

**Tests**: `tests/unit/core/test_[component].py`
- `test_contract_is_frozen`
- `test_contract_fields`

**Commit**:
```bash
git add -A && git commit -m "core: add [Component] type contract"
```

**Confidence Gate**: 90% (core module)

---

### Task 1.2: [Next type contract if needed]
[Same structure]

---

## Phase 2: Core Implementation

### Task 2.1: Implement [Component] Logic

**Subsystem**: Core
**File**: `bengal/core/[component].py`
**Depends on**: 1.1

**Changes**:
- Add `from_dict()` factory method
- Add computed properties

**Tests**: `tests/unit/core/test_[component].py`
- `test_from_dict_creates_instance`
- `test_computed_property_returns_expected`

**Commit**:
```bash
git add -A && git commit -m "core: implement [Component] logic"
```

---

## Phase 3: Integration Wiring

**CRITICAL**: This phase ensures new code is actually reachable from user entry points.
Every new component MUST have at least one integration task with explicit call sites.

### Task 3.1: Wire [Component] into [Caller]

**Subsystem**: [Orchestration/CLI/etc]
**Call Site**: `path/to/file.py:method_name()` (line ~N)
**Caller**: `ClassName.method()` or `module.function()`
**Depends on**: 2.1

**Current Code** (before):
```python
# Exact code being modified
result = await self._execute_tool(tool_call)
```

**New Code** (after):
```python
# Exact code after modification
result = await self.tool_emulator.execute(tool_call)
```

**Integration Checklist**:
- [ ] Import added at top of file
- [ ] Method/function is called (not just defined)
- [ ] Can trace from CLI entry → this call site → new component
- [ ] No dead code paths

**Commit**:
```bash
git add -A && git commit -m "<scope>: wire [Component] into [caller]"
```

---

### Task 3.2: [Additional wiring if multiple entry points]

[Same structure - one task per call site that needs wiring]

---

## Phase 4: Verification

### Task 4.1: Add Integration Tests

**Subsystem**: Tests
**File**: `tests/integration/test_[feature].py`
**Depends on**: 3.1

**Tests**:
- `test_end_to_end_[feature]` - Full path from entry to exit
- `test_[feature]_with_edge_cases`

**Test Root**: `tests/roots/test-[feature]/` (if new fixture needed)

**Commit**:
```bash
git add -A && git commit -m "tests: add integration tests for [feature]"
```

---

### Task 4.2: Verify Wiring is Reachable

**Validation Steps**:
```bash
# 1. Grep for the new component - is it imported?
grep -rn "from.*import.*NewComponent" src/

# 2. Grep for call sites - is it actually called?
grep -rn "new_component\." src/

# 3. Trace from CLI to new code
# Document the path: cli/main.py → agent/core.py → new_component.py
```

**Reachability Proof** (REQUIRED):
```
Entry: cli/chat.py:main()
  → agent/core.py:Agent.run()
    → agent/core.py:Agent._handle_tool()
      → [NEW] tools/emulator.py:ToolEmulator.execute()
```

**Gate**: Plan is INCOMPLETE if any new component lacks a reachability proof.

---

## Dependencies

```mermaid
graph TD
    1.1[1.1 Type Contract] --> 2.1[2.1 Implementation]
    2.1 --> 3.1[3.1 Integration Wiring]
    3.1 --> 4.1[4.1 Integration Tests]
    4.1 --> 4.2[4.2 Reachability Proof]
```

---

## Quality Gates

| Phase | Subsystem | Required Confidence |
|-------|-----------|---------------------|
| 1 | Core | 90% |
| 2 | Core | 90% |
| 3 | Integration | 90% |
| 4 | Tests | 85% |

---

## Checklist

- [ ] All tasks have pre-drafted commits
- [ ] Each task is atomic (one commit)
- [ ] Dependencies are explicit
- [ ] Type contracts come first
- [ ] Core tasks require 90% confidence
- [ ] Integration tests defined
- [ ] **Phase 3 has explicit call sites (file:line)**
- [ ] **Phase 4 has reachability proof**
```

---

## Task Principles

1. **Types First** - Define contracts before implementation
2. **Atomic** - One logical change per task
3. **Ordered** - Dependencies explicit
4. **Testable** - Each task has verification criteria
5. **Committable** - Each task = one atomic commit
6. **Wired** - Every component has explicit integration points

---

## After Planning

```bash
# Move plan to ready
mv plan/evaluated/rfc-[name].md plan/ready/
# Create plan file
# plan/ready/plan-[name].md

# Update RFC status
Status: Ready

# Begin implementation
::implement
```

---

## Related

- `commands/rfc` - RFC drafting
- `commands/rfc-eval` - RFC evaluation
- `commands/implement` - Execute tasks
- `commands/coverage-analysis` - Journey mapping (run before RFC)
- `modules/types-as-contracts` - Type-first philosophy
