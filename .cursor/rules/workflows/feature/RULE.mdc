---
description: Full feature development workflow - research â†’ coverage â†’ RFC â†’ plan (ready for implementation)
alwaysApply: false
---

# Feature Workflow

Full feature development flow from research through planning.

**Shortcut**: `::workflow-feature`

**Output**: RFC + Plan ready for implementation

---

## When to Use

- Starting a **new feature** from scratch
- Need **full design documentation**
- **Architectural changes** required
- Want to think through before coding

---

## Workflow Chain

```yaml
1. ::research (10-15 min)
   Input: Feature description
   Output: Evidence-backed understanding of current state

2. ::coverage (10-15 min)
   Input: Research findings
   Output: Actors, journeys, integration points identified
   Gate: All entry/exit points mapped

3. ::rfc (15-20 min)
   Input: Research + Coverage findings
   Output: RFC with design options and recommendation

4. Review checkpoint
   Action: User reviews RFC
   Gate: Confidence â‰¥ 85%

5. ::plan (10 min)
   Input: Approved RFC + Coverage analysis
   Output: Actionable task list with explicit integration wiring
```

**Total time**: 45-60 minutes

---

## Procedure

### Phase 1: Research

```yaml
command: ::research
focus:
  - Current implementation in affected modules
  - Related tests
  - Architecture patterns in use
  - Similar features for patterns

output:
  - Claims about current state
  - Gaps identified
  - Confidence scores
```

### Phase 2: Coverage Analysis

```yaml
command: ::coverage
focus:
  - Who/what initiates this feature? (actors)
  - What are all the ways to use it? (journeys)
  - Where does it connect to existing code? (integration points)
  - What can go wrong? (error paths)

output:
  - Actor table (internal + external)
  - Journey map (happy path, error, edge cases)
  - Integration point inventory
  - Edge case catalog

gate: Every new component must have at least one integration point identified
```

### Phase 3: RFC

```yaml
command: ::rfc
sections:
  - Executive Summary
  - Problem Statement (with evidence)
  - Goals and Non-Goals
  - Design Options (at least 2)
  - Recommended Approach
  - Architecture Impact
  - **Integration Points** (from coverage analysis)
  - Risks and Mitigations
  - Implementation Plan outline

gate: Confidence â‰¥ 85%
```

### Phase 4: User Review

```markdown
## ðŸ“‹ RFC Review Checkpoint

**RFC**: [Title]
**Confidence**: [N]% [emoji]

Please review:
- [ ] Problem statement accurate?
- [ ] Goals align with your needs?
- [ ] Recommended approach acceptable?
- [ ] **Integration points complete?**
- [ ] Risks understood?

**Options**:
- "Looks good" â†’ Continue to planning
- "Change [X]" â†’ Revise RFC
- "Need more research on [Y]" â†’ Additional research
```

### Phase 5: Plan

```yaml
command: ::plan
output:
  - Task breakdown by subsystem
  - Dependency order
  - Pre-drafted commit messages
  - **Explicit integration wiring tasks (file:line)**
  - **Reachability proofs**
  - Test requirements per task
  - Estimated effort
```

---

## Output

At the end of this workflow, you have:

1. **Coverage analysis** (may be inline or separate doc)
   - Actors and journeys mapped
   - Integration points identified
   - Edge cases cataloged

2. **RFC document** in `plan/drafted/rfc-[name].md`
   - Evidence-backed problem statement
   - Analyzed design options
   - Clear recommendation
   - Architecture impact documented
   - **Integration points section**

3. **Plan document** in `plan/drafted/plan-[name].md`
   - Atomic tasks
   - Ordered by dependency
   - **Phase 3: Integration Wiring with explicit call sites**
   - **Phase 4: Verification with reachability proofs**
   - Ready for `::implement`

---

## Example

```text
User: "::workflow-feature - add pagination to page collections"

AI:
  Phase 1 - Research (12 min):
    - Found: bengal/core/page/collection.py handles collections
    - Found: No existing pagination support
    - Found: Similar pattern in taxonomy_index.py
    - Confidence: 88%

  Phase 2 - Coverage (10 min):
    - Actors: CLI user, template author, build system
    - Happy path: User configures pagination â†’ build generates pages
    - Integration points:
      - bengal/orchestration/build.py:build_collections() (line 234)
      - bengal/rendering/helpers.py:paginate() (new)
      - cli/build.py:main() (existing entry)
    - Edge cases: Empty collection, 1 item, exact page boundary

  Phase 3 - RFC (18 min):
    - Problem: Large collections hurt build time and page load
    - Option A: Client-side pagination
    - Option B: Build-time pagination (recommended)
    - Option C: Hybrid approach
    - Integration: build_collections() will call new paginator
    - Architecture impact: New PaginatedCollection type
    - Confidence: 91%

  Checkpoint:
    "RFC ready for review. Confidence 91%. Proceed with planning?"

  Phase 4 - Plan (8 min):
    - Task 1.1: Define PaginatedPage type
    - Task 1.2: Add pagination config to bengal.toml schema
    - Task 2.1: Implement PaginationOrchestrator
    - Task 2.2: Add pagination template helpers
    - Task 3.1: Wire paginator into build_collections() at line 234
    - Task 3.2: Wire pagination helpers into template context
    - Task 4.1: Add integration tests
    - Task 4.2: Reachability proof: cli â†’ build â†’ paginator â†’ helpers
```

---

## Next Steps After Workflow

```yaml
ready_for:
  - ::implement (execute tasks from plan)
  - Manual implementation following plan

follow_up:
  - ::validate (after implementation)
  - ::retro (after shipping)
```

---

## Related

- `commands/research` - Evidence extraction
- `commands/coverage-analysis` - Actor/journey mapping
- `commands/rfc` - RFC drafting
- `commands/plan` - Task breakdown
- `workflows/fix` - Simpler workflow for fixes
- `workflows/ship` - Pre-release validation
